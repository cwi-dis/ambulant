# This script generates a Python interface for an Apple Macintosh Manager.
# It uses the "bgen" package to generate C code.
# The function specifications are generated by scanning the mamager's header file,
# using the "scantools" package (customized for this particular manager).

import string
from bgen import *
from bgenCxxSupport import CxxMethodGenerator, CxxMixin
# Declarations that change for each manager
MODNAME = 'ambulant'                         # The name of the module

# The following is *usually* unchanged but may still require tuning
MODPREFIX = 'PyAm'                        # The prefix for module-wide routines
INPUTFILE = 'ambulantgen.py' # The file generated by the scanner
OUTPUTFILE = MODNAME + "module.cpp"       # The file generated by this program


# Create the type objects

includestuff = """
#include "ambulant/config/config.h"
"""
execfile("ambulantincludegen.py")

includestuff = includestuff + """

// Forward declarations:
extern PyObject *nodeObj_New(ambulant::lib::node* itself);
extern int surfaceObj_Convert(PyObject *v, ambulant::common::surface* *p_itself);

/*
** Parse/generate various objects
*/
PyObject *bool_New(bool itself)
{
    if (itself) {
        Py_RETURN_TRUE;
    } 
    Py_RETURN_FALSE;
}

int
bool_Convert(PyObject *v, bool *p_itself)
{
    int istrue = PyObject_IsTrue(v);
    if (istrue < 0) return 0;
    *p_itself = (istrue > 0);
    return 1;
}


PyObject *cxx_std_string_New(std::string& itself)
{
    return PyString_FromString(itself.c_str());
}

int
cxx_std_string_Convert(PyObject *v, std::string *p_itself)
{
    char *cstr = PyString_AsString(v);
    if (cstr == NULL) return 0;
    *p_itself = cstr;
    return 1;
}


PyObject *ambulant_url_New(ambulant::net::url& itself)
{
    return PyString_FromString(itself.get_url().c_str());
}

int
ambulant_url_Convert(PyObject *v, ambulant::net::url *p_itself)
{
    char *cstr = PyString_AsString(v);
    if (cstr == NULL) return 0;
    std::string cxxstr = cstr;
    ambulant::net::url url(cxxstr);
    *p_itself = url;
    return 1;
}


PyObject *ambulant_screen_rect_New(ambulant::lib::screen_rect_int& itself)
{
    return Py_BuildValue("llll", itself.left(), itself.top(), itself.right(), itself.bottom());
}

int
ambulant_screen_rect_Convert(PyObject *v, ambulant::lib::screen_rect_int *p_itself)
{
    int l, t, r, b;
    
    if (!PyArg_Parse(v, "llll", &l, &t, &r, &b))
        return 0;
    p_itself->set_coord(l, t, r, b);
    return 1;
}

PyObject *ambulant_rect_New(ambulant::lib::rect& itself)
{
    return Py_BuildValue("llll", itself.left(), itself.top(), itself.right(), itself.bottom());
}

int
ambulant_rect_Convert(PyObject *v, ambulant::lib::rect *p_itself)
{
    int l, t, r, b;
    
    if (!PyArg_Parse(v, "llll", &l, &t, &r, &b))
        return 0;
    *p_itself = ambulant::lib::rect(
                ambulant::lib::point(l, t),
                ambulant::lib::size(r-l, b-t));
    return 1;
}

PyObject *ambulant_point_New(ambulant::lib::point& itself)
{
    return Py_BuildValue("ll", itself.x, itself.y);
}

int
ambulant_point_Convert(PyObject *v, ambulant::lib::point *p_itself)
{
    if (!PyArg_Parse(v, "ll", &p_itself->x, &p_itself->y))
        return 0;
    return 1;
}

PyObject *ambulant_size_New(ambulant::lib::size& itself)
{
    return Py_BuildValue("ll", itself.w, itself.h);
}

int
ambulant_size_Convert(PyObject *v, ambulant::lib::size *p_itself)
{
    if (!PyArg_Parse(v, "ll", &p_itself->w, &p_itself->h))
        return 0;
    return 1;
}

"""

finalstuff = """
// Declare initambulant as a C external:

extern "C" void initambulant(); 
"""

initstuff = """
"""

variablestuff="""
"""

bool = OpaqueByValueType("bool", "bool")
size_t = Type("size_t", "l")
unsigned_int = Type("unsigned int", "l")
std_string = OpaqueByRefType("std::string", "cxx_std_string")

InBuffer = VarInputBufferType('char', 'size_t', 'l')

# Ambulant-specific
net_url = OpaqueByRefType("ambulant::net::url", "ambulant_url")
screen_rect_int = OpaqueByRefType("ambulant::lib::screen_rect_int", "ambulant_screen_rect")
rect = OpaqueByRefType("ambulant::lib::rect", "ambulant_rect")
point = OpaqueByRefType("ambulant::lib::point", "ambulant_point")
size = OpaqueByRefType("ambulant::lib::size", "ambulant_size")
zindex_t = Type("ambulant::common::zindex_t", "l")
cookie_type = Type("ambulant::common::playable::cookie_type", "l")
color_t = Type("ambulant::lib::color_t", "l") # XXXX Split into RGB
event_priority = Type("ambulant::lib::event_processor::event_priority", "l")
timestamp_t = Type("ambulant::net::timestamp_t", "L")
time_type = Type("ambulant::lib::abstract_timer::time_type", "l")
tiling = Type("ambulant::common::tiling", "l")
fit_t = Type("ambulant::common::fit_t", "l")
sound_alignment = Type("ambulant::common::sound_alignment", "l")

# Our (opaque) objects

class MyGlobalObjectDefinition(CxxMixin, PEP253Mixin, GlobalObjectDefinition):
    def outputCheckNewArg(self):
        Output('if (itself == NULL)')
        OutLbrace()
        Output('Py_INCREF(Py_None);')
        Output('return Py_None;')
        OutRbrace()
        # XXX Add refcount, if needed
        
    def outputCheckConvertArg(self):
        Output('if (v == Py_None)')
        OutLbrace()
        Output('*p_itself = NULL;')
        Output('return 1;')
        OutRbrace()
        
    def outputStructMembers(self):
        GlobalObjectDefinition.outputStructMembers(self)
        # XXX Output("bool owned;")
        
    def outputInitStructMembers(self):
        GlobalObjectDefinition.outputInitStructMembers(self)
        # XXX init owned, if needed
        
    def outputCleanupStructMembers(self):
        # XXX For refcounted objects decref
        # XXX For owned objects delete
        pass

    def outputCompare(self):
        Output()
        Output("static int %s_compare(%s *self, %s *other)", self.prefix, self.objecttype, self.objecttype)
        OutLbrace()
        Output("if ( self->ob_itself > other->ob_itself ) return 1;")
        Output("if ( self->ob_itself < other->ob_itself ) return -1;")
        Output("return 0;")
        OutRbrace()

    def outputHash(self):
        Output()
        Output("static int %s_hash(%s *self)", self.prefix, self.objecttype)
        OutLbrace()
        Output("return (int)self->ob_itself;")
        OutRbrace()

    def output_tp_newBody(self):
        Output("PyObject *self;")
        Output
        Output("if ((self = type->tp_alloc(type, 0)) == NULL) return NULL;")
        Output("((%s *)self)->ob_itself = NULL;", self.objecttype)
        ##Output("((%s *)self)->ob_freeit = CFRelease;", self.objecttype)
        Output("return self;")

    def output_tp_initBody(self):
        Output("%s itself;", self.itselftype)
        Output("char *kw[] = {\"itself\", 0};")
        Output()
        Output("if (PyArg_ParseTupleAndKeywords(args, kwds, \"O&\", kw, %s_Convert, &itself))",
                self.prefix)
        OutLbrace()
        Output("((%s *)self)->ob_itself = itself;", self.objecttype)
        Output("return 0;")
        OutRbrace()
        Output("return -1;")

# Create the generator groups and link them
module = Module(MODNAME, MODPREFIX, includestuff, finalstuff, initstuff, variablestuff)
functions = []

execfile("ambulantobjgen.py")

# Some type synonyms
node_interface_ptr = node_ptr
lib_node_ptr = node_ptr
const_node_interface_ptr = const_node_ptr
methods_node_interface = methods_node

lib_event_processor_ptr = event_processor_ptr
abstract_event_processor_ptr = event_processor_ptr
methods_abstract_event_processor = methods_event_processor

lib_event_ptr = event_ptr
lib_timer_ptr = abstract_timer_ptr
lib_screen_rect_int = screen_rect_int
lib_point = point
lib_size = size
lib_color_t = color_t
lib_rect = rect
common_zindex_t = zindex_t
const_cookie_type_ref = cookie_type

# Do the type tests
execfile("ambulanttypetest.py")

# Create the generator classes used to populate the lists
Function = FunctionGenerator
Method = CxxMethodGenerator

# Create and populate the lists

execfile(INPUTFILE)


# add the populated lists to the generator groups
# (in a different wordl the scan program would generate this)
for f in functions: module.add(f)

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# ADD add forloop here

# generate output (open the output file as late as possible)
SetOutputFileName(OUTPUTFILE)
module.generate()
