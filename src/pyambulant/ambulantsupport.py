# This script generates a Python interface for ambulant.
# It uses the "bgen" package to generate C code.
# The function specifications are generated by scanning the  header files,
# using the "scantools" package.

import string
from bgen import *
from bgenCxxSupport import *
# Declarations that change for each manager
MODNAME = 'ambulant'                         # The name of the module

# The following is *usually* unchanged but may still require tuning
MODPREFIX = 'PyAm'                        # The prefix for module-wide routines
INPUTFILE = 'ambulantgen.py' # The file generated by the scanner
PY2CXXFILE = MODNAME + "module.cpp"       # The Python to C++ glue code
CXX2PYFILE = MODNAME + "interface.cpp"   # The C++ to Python glue code
CXX2PYDECLFILE = MODNAME + "interface.h"     # The C++ to Python declarations

# Create the type objects

includestuff = """
/*AMBULANT_FOREIGN_INDENT_RULES*/
#include "ambulant/config/config.h"
#include "ambulant/version.h"
"""
execfile("ambulantincludegen.py")

includestuff = includestuff + """
// Should have been included through genobj.py but that caused problems
#ifdef WITH_GTK
#include "ambulant/gui/gtk/gtk_factory.h"
#include <pygobject.h>
#include <pygtk/pygtk.h>
#if GTK_MAJOR_VERSION < 3
#define WITH_GTK2
#endif
#endif
#include "ambulantinterface.h"
#include "ambulantutilities.h"
#include "ambulantmodule.h"

// The Python interface does not qualify strings with const, so we have to
// disable warnings about non-writeable strings (zillions of them)

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wwrite-strings"
#endif

extern PyObject *audio_format_choicesObj_New(ambulant::net::audio_format_choices *itself);
extern int audio_format_choicesObj_Convert(PyObject *v, ambulant::net::audio_format_choices *p_itself);
extern int cobject_Convert(PyObject *v, void **p_itself);

/* Workaround for "const" added in Python 2.5. But removed before 2.5a1? */
#if PY_VERSION_HEX >= 0x02050000 && PY_VERSION_HEX < 0x020500a1
# define Py_KEYWORDS_STRING_TYPE const char
#else
# define Py_KEYWORDS_STRING_TYPE char
#endif

#ifdef WITH_GTK
static PyTypeObject *PyGObject_Type = NULL;
int
PyGObjectAsVoidPtr_Convert(PyObject *v, void **p_itself)
{
    static bool pygtk_initialized = false;
#if 0
    if (v == NULL || v->ob_type != PyGObject_Type) {
        PyErr_SetString(PyExc_TypeError, "PyGObject expected");
        return 0;
    }
#endif
    *p_itself = (void*)GTK_WIDGET(((PyGObject *)v)->obj);
    return 1;
}
#endif
"""

finalstuff = """
// Helper routines to enable object identity to be maintained
// across the bridge:

cpppybridge *
pycppbridge_getwrapper(PyObject *o)
{
    if (!pycppbridge_Check(o)) {
    	PyErr_Warn(PyExc_Warning, "ambulant: Passing non-pycppbridge object to C++");
    	return NULL;
    }
    pycppbridgeObject *bo = (pycppbridgeObject *)o;
    return bo->ob_wrapper;
}

void
pycppbridge_setwrapper(PyObject *o, cpppybridge *w)
{
    if (!pycppbridge_Check(o)) {
        PyErr_SetString(PyExc_SystemError, "ambulant: attempt to set wrapper for non-bridged object");
    } else {
        pycppbridgeObject *bo = (pycppbridgeObject *)o;
        if (bo->ob_wrapper)
            PyErr_SetString(PyExc_SystemError, "ambulant: attempt to set wrapper second time");
        bo->ob_wrapper = w;
    }
}

// Declare initambulant as a C external:

extern "C" void initambulant(); 
"""

initstuff = """
PyEval_InitThreads();
#ifdef WITH_GTK2
init_pygobject();
init_pygtk();
PyObject *module = PyImport_ImportModule("gobject");
if (module)
    PyGObject_Type = (PyTypeObject*)PyObject_GetAttrString(module, "GObject");
Py_XDECREF(module);
#endif // WITH_GTK2
"""

variablestuff="""
"""

print "=== Defining simple types ==="

bool = OpaqueByValueType("bool", "bool")
size_t = Type("size_t", "l")
unsigned_int = Type("unsigned int", "l")
progress_type = Type("ambulant::lib::transition_info::progress_type", "d")
std_string = StdStringType()
const_std_string_ref = StdStringType("const std::string&")
xml_string = StdStringType("ambulant::lib::xml_string")
lib_xml_string = xml_string
const_lib_xml_string = xml_string
const_xml_string_ref = StdStringType("const ambulant::lib::xml_string&")
const_lib_xml_string_ref = const_xml_string_ref
q_name_pair = StdPairType(xml_string, xml_string, "ambulant::lib::q_name_pair")
const_q_name_pair_ref = StdPairType(xml_string, xml_string, 
    "const ambulant::lib::q_name_pair&", "ambulant::lib::q_name_pair")
duration = StdPairType(bool, double, "ambulant::common::duration")

InBuffer = VarInputBufferType('char', 'size_t', 'l')
return_stringptr = Type("const char *", "z")  # ONLY FOR RETURN VALUES!! May be None/NULL.
# output_stringptr = Type("char *", "s")  # BE CAREFUL!
output_malloc_buf = MallocHeapOutputBufferType("char", "size_t", "l")
unsigned_char_ptr = Type("unsigned char *", "s")

# Ambulant-specific
q_attributes_list = OpaqueByRefType("ambulant::lib::q_attributes_list", "ambulant_attributes_list")
region_dim = OpaqueByRefType("ambulant::common::region_dim", "ambulant_region_dim")
net_url = OpaqueByRefType("ambulant::net::url", "ambulant_url")
const_net_url_ref = OpaqueByRefType("const ambulant::net::url&", "ambulant_url")
rect = OpaqueByRefType("ambulant::lib::rect", "ambulant_rect")
lib_rect_ptr = OpaqueByValueType("ambulant::lib::rect *", "ambulant_rect")
point = OpaqueByRefType("ambulant::lib::point", "ambulant_point")
const_lib_point_ref = OpaqueByRefType("const ambulant::lib::point&", "ambulant_point")
const_lib_rect_ref = OpaqueByRefType("const ambulant::lib::rect&", "ambulant_rect")
size = OpaqueByRefType("ambulant::lib::size", "ambulant_size")
zindex_t = Type("ambulant::common::zindex_t", "l")
cookie_type = Type("ambulant::common::playable::cookie_type", "l")
const_cookie_type = cookie_type
color_t = Type("ambulant::lib::color_t", "l") # XXXX Split into RGB
event_priority = Type("ambulant::lib::event_priority", "l")
timestamp_t = Type("ambulant::net::timestamp_t", "L")
time_type = Type("ambulant::lib::timer::time_type", "l")
lib_timer_time_type = time_type
signed_time_type = Type("ambulant::lib::timer::signed_time_type", "l")
tiling = Type("ambulant::common::tiling", "l")
fit_t = Type("ambulant::common::fit_t", "l")
sound_alignment = Type("ambulant::common::sound_alignment", "l")
pause_display = Type("ambulant::common::pause_display", "l")
pixel_order = Type("ambulant::net::pixel_order", "l")
net_pixel_order = pixel_order

pycobject = OpaqueByValueType("void*", "cobject")
pygobject = OpaqueByValueType("void *", "PyGObjectAsVoidPtr")

# This is a bit of a hack. These types are opaque, really.
renderer_private_data_ptr = Type("ambulant::common::renderer_private_data *", "l")
renderer_private_id = Type("ambulant::common::renderer_private_id", "l")

# Another hack: for some reason these show up in typetest while they are not used??
ambulant_gtk_window_ptr=None
gtk_renderer_factory_ptr=None
gtk_video_factory_ptr=None
sdl_window_factory_ptr=None

common_playable_factory_machdep_ptr = FakeType("NULL")

# A helper object, used as baseclass for our Python objects to enable
# bridging objects back-and-forth between Python and C++ while maintaining
# object identity.
class MyBridgeObjectDefinition(CxxMixin, PEP253Mixin, GlobalObjectDefinition):

    def __init__(self, name, prefix):
        GlobalObjectDefinition.__init__(self, name, prefix, None)
        self.constructors = []
        
    def outputNew(self):
        pass
        
    def outputConvert(self):
        pass
        
    def outputCheck(self):
        pass
        
    def outputStructMembers(self):
        Output("cpppybridge *ob_wrapper;")
        
    def outputInitStructMembers(self):
        Output("ob_wrapper = NULL;")
        
    def outputCleanupStructMembers(self):
        Output("delete self->ob_wrapper;")
        Output("self->ob_wrapper = NULL;")

    def output_tp_new(self):
        Output("#define %s_tp_new PyType_GenericNew", self.prefix)
        
# Our (opaque) objects
class MyGlobalObjectDefinition(CxxMixin, PEP253Mixin, GlobalObjectDefinition):

    def __init__(self, name, prefix, itselftype):
        GlobalObjectDefinition.__init__(self, name, prefix, itselftype)
        self.constructors = []
        
    def add(self, g, dupcheck=0):
        if g.name == self.name:
            g.setselftype(self.objecttype, self.itselftype)
            self.constructors.append(g)
            print "Adding constructor for", self.name
        else:
            GlobalObjectDefinition.add(self, g, dupcheck)
            
    def outputCheckNewArg(self):
        Output('if (itself == NULL)')
        OutLbrace()
        Output('Py_INCREF(Py_None);')
        Output('return Py_None;')
        OutRbrace()
        CxxMixin.outputCheckNewArg(self)
        # XXX Add refcount, if needed
        
    def outputCheckConvertArg(self):
        Output('if (v == Py_None)')
        OutLbrace()
        Output('*p_itself = NULL;')
        Output('return 1;')
        OutRbrace()
        CxxMixin.outputCheckConvertArg(self)
        
    def outputStructMembers(self):
        Output("void *ob_dummy_wrapper; // Overlays bridge object storage")
        GlobalObjectDefinition.outputStructMembers(self)
        # XXX Output("bool owned;")
        
    def outputInitStructMembers(self):
        Output("it->ob_dummy_wrapper = NULL; // XXXX Should be done in base class")
        GlobalObjectDefinition.outputInitStructMembers(self)
        # XXX init owned, if needed
        
    def outputCleanupStructMembers(self):
        # XXX For refcounted objects decref
        # XXX For owned objects delete
        pass

    def outputCompare(self):
        Output()
        Output("static int %s_compare(%s *self, %s *other)", self.prefix, self.objecttype, self.objecttype)
        OutLbrace()
        Output("if ( self->ob_itself > other->ob_itself ) return 1;")
        Output("if ( self->ob_itself < other->ob_itself ) return -1;")
        Output("return 0;")
        OutRbrace()

    def outputHash(self):
        Output()
        Output("static long %s_hash(%s *self)", self.prefix, self.objecttype)
        OutLbrace()
        Output("return (long)self->ob_itself;")
        OutRbrace()

    def output_tp_newBody(self):
        Output("PyObject *_self;")
        Output()
        Output("if ((_self = type->tp_alloc(type, 0)) == NULL) return NULL;")
        Output("((%s *)_self)->ob_itself = NULL;", self.objecttype)
        ##Output("((%s *)self)->ob_freeit = CFRelease;", self.objecttype)
        Output("return _self;")

    def output_tp_initBody(self):
        Output("%s itself;", self.itselftype)
        Output("Py_KEYWORDS_STRING_TYPE *kw[] = {\"itself\", 0};")
        Output()
        for con in self.constructors:
            con.outputConstructorBody()
        Output("if (PyArg_ParseTupleAndKeywords(_args, _kwds, \"O&\", kw, %s_Convert, &itself))",
                self.prefix)
        OutLbrace()
        Output("((%s *)_self)->ob_itself = itself;", self.objecttype)
        Output("return 0;")
        OutRbrace()
        Output("return -1;")
        
# Create the generator groups and link them
module = CxxModule(MODNAME, MODPREFIX, includestuff, finalstuff, initstuff, variablestuff)
functions = []

# Start with adding the bridging base class
pycppbridge = MyBridgeObjectDefinition("pycppbridge", "pycppbridge")
module.addobject(pycppbridge)

print "=== generating object definitions ==="

execfile("ambulantobjgen.py")

print "=== declaring more types ==="

# XXXX Temporarily disabled
methods_none_playable_factory = []

audio_format = TupleType("ambulant::net::audio_format",
        (std_string, "mime_type"),
        (std_string, "name"),
        (FakeType("(void *)0"), "parameters"),
        (int, "samplerate"),
        (int, "channels"),
        (int, "bits"))
audio_format_ref = TupleType("ambulant::net::audio_format&",
        (std_string, "mime_type"),
        (std_string, "name"),
        (FakeType("(void *)0"), "parameters"),
        (int, "samplerate"),
        (int, "channels"),
        (int, "bits"))
video_format = TupleType("ambulant::net::video_format",
        (std_string, "mime_type"),
        (std_string, "name"),
        (FakeType("(void*)0"), "parameters"),
        (timestamp_t, "frameduration"),
        (int, "width"),
        (int, "height"))
video_format_ref = TupleType("ambulant::net::video_format&",
        (std_string, "mime_type"),
        (std_string, "name"),
        (FakeType("(void*)0"), "parameters"),
        (timestamp_t, "frameduration"),
        (int, "width"),
        (int, "height"))
const_audio_format_ref = TupleType("const ambulant::net::audio_format&",
        (std_string, "mime_type"),
        (std_string, "name"),
        (FakeType("(void *)0"), "parameters"),
        (int, "samplerate"),
        (int, "channels"),
        (int, "bits"))
        
class audio_format_choicesObjectDefinition(MyGlobalObjectDefinition):
    baseclass = None
    argref = "*"
    argconst = "const "
    def output_tp_newBody(self):
        Output("PyObject *_self;")
        Output()
        Output("if ((_self = type->tp_alloc(type, 0)) == NULL) return NULL;")
        #Output("((%s *)_self)->ob_itself = NULL;", self.objecttype)
        Output("return _self;")

    def outputCheckConvertArg(self):
        CxxMixin.outputCheckConvertArg(self)

    def outputCompare(self):
        Output()
        Output("#define %s_compare NULL", self.prefix)

    def outputHash(self):
        Output()
        Output("#define %s_hash NULL", self.prefix)

audio_format_choices_object = audio_format_choicesObjectDefinition('audio_format_choices', 'audio_format_choicesObj', 'ambulant::net::audio_format_choices')
methods_audio_format_choices = []
module.addobject(audio_format_choices_object)

class OpaqueByFunnyRefType(OpaqueByRefType):
    def mkvalueArgs(self, name):
        return "%s(&%s)" % (self.new, name)

audio_format_choices = OpaqueByFunnyRefType('ambulant::net::audio_format_choices', 'audio_format_choicesObj')
audio_format_choices_ptr = OpaqueByValueType('ambulant::net::audio_format_choices*', 'audio_format_choicesObj')
const_audio_format_choices_ptr = OpaqueByValueType('const ambulant::net::audio_format_choices*', 'audio_format_choicesObj')

# Some type synonyms
lib_node_ptr = node_ptr

lib_event_processor_ptr = event_processor_ptr
ambulant_lib_event_processor_ptr = event_processor_ptr
lib_transition_info_ptr = transition_info_ptr
lib_xml_string = xml_string

common_duration = duration
common_surface_ptr = surface_ptr
common_playable_ptr = playable_ptr
common_region_info_ptr = region_info_ptr
common_gui_window_ptr = gui_window_ptr
common_gui_events_ptr = gui_events_ptr
common_bgrenderer_ptr = bgrenderer_ptr
common_gui_player_ptr = gui_player_ptr
common_playable_factory_ptr = playable_factory_ptr
common_window_factory_ptr = window_factory_ptr
common_state_component_ptr = state_component_ptr
lib_document_ptr = document_ptr
lib_event_ptr = event_ptr
ambulant_lib_event_ptr = event_ptr
lib_timer_ptr = timer_ptr
lib_timer_sync_factory_ptr = timer_sync_factory_ptr
lib_point = point
lib_size = size
lib_color_t = color_t
lib_rect = rect
common_zindex_t = zindex_t
common_embedder_ptr = embedder_ptr
playable_notification_cookie_type = cookie_type
common_playable_notification_cookie_type = cookie_type
common_playable_notification_ptr = playable_notification_ptr
net_audio_datasource_ptr = audio_datasource_ptr
ambulant_net_url = net_url
url = net_url

const_ambulant_net_url_ref = net_url
posix_datasource_ptr = datasource_ptr
stdio_datasource_ptr = datasource_ptr
filter_datasource_impl_ptr = datasource_ptr
lib_global_parser_factory_ptr = global_parser_factory_ptr
lib_node_factory_ptr = node_factory_ptr
net_datasource_factory_ptr = datasource_factory_ptr
common_factories_ptr = factories_ptr

print "=== Testing availability of support for all needed C types ==="

# Do the type tests
execfile("ambulanttypetest.py")

print "=== Populating method and function lists ==="

class AllowThreadMixin:
    def beginallowthreads(self):
        Output("PyThreadState *_save = PyEval_SaveThread();")
        
    def endallowthreads(self):
        Output("PyEval_RestoreThread(_save);")
        
class Function(AllowThreadMixin, FunctionGenerator):
    pass
class Method(AllowThreadMixin, CxxMethodGenerator):
    pass
ConstMethod = Method
ConstructorMethod = CxxConstructorGenerator

# Create and populate the lists

execfile(INPUTFILE)

print "=== Adding methods to objects, resolving duplicates ==="

# add the populated lists to the generator groups
# (in a different wordl the scan program would generate this)
for f in functions: module.add(f)

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# Resolve duplicates
module.resolveduplicates()

# ADD add forloop here

print "=== Generating Python->C++ interface module ==="

# generate output (open the output file as late as possible)
SetOutputFileName(PY2CXXFILE)
module.generate()

# Now we start to get really gross. We want to reuse as much as possible
# when generating the C++ wrapper classes around Python objects. So, we
# redefine MyGlobalObjectDefinition, create a new module based on the
# wrapper module, reread the object definitions file
# (which will then create a whole new set of objects based on the new baseclass
# and reinitialize the methodlists to be empty)
# and call generate on this new module. Poof! We have the interface
# the other way...
from bgenBackSupport import *
class BackVarInputBufferType(VarInputBufferType):
    
    def getAuxDeclarations(self, name):
        return []
        
    def mkvalueArgs(self, name):
        return "%s__in__, (int)%s__len__" % (name, name)

InBuffer = BackVarInputBufferType('char', 'size_t', 'l')

includestuff = ""
finalstuff = ""
execfile("ambulantincludegen.py")
includestuff += """
#include "ambulant/lib/node_navigator.h"
"""


class MyGlobalObjectDefinition(BackObjectDefinition):
    pass
    
class NoFunctionGenerator(FunctionGenerator):
    def generate(self):
        pass
        
    def setClass(self, name):
        pass
        
    def generateDeclaration(self):
        pass
        
    def checkreturnvar(self):
        pass
        
    def checkgenerate(self):
        return False
        
    def generateAttributeExistenceTest(self):
        pass
        
Function = NoFunctionGenerator
Method = BackMethodGenerator
ConstMethod = BackMethodGenerator
ConstructorMethod = NoFunctionGenerator

module = BackModule("pyambulant", includestuff, finalstuff)
functions = []
print "=== generating object definitions for callbacks ==="

execfile("ambulantobjgen.py")

print "=== declaring more types for callbacks ==="
# Some type synonyms
lib_node_ptr = node_ptr

lib_event_processor_ptr = event_processor_ptr

lib_event_ptr = event_ptr
lib_timer_ptr = timer_ptr
lib_point = point
lib_size = size
lib_color_t = color_t
lib_rect = rect
common_zindex_t = zindex_t
net_audio_datasource_ptr = audio_datasource_ptr

gui_window_object.baseconstructors.append("ambulant::common::gui_window(0)")

# We do not want callback support for audio_format__choices.

del audio_format_choices_object

print "=== Populating method and function lists for callbacks ==="
#import pdb ; pdb.set_trace()
execfile(INPUTFILE)

print "=== Adding methods to objects, callbacks ==="

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# Dummy versions of methods we cannot support:
gui_screen_object.othermethods = [
    """#ifdef CPP_TO_PYTHON_BRIDGE
    bool get_screenshot(const char*, char**, size_t*) { return false; }
    #endif""",
]

node_context_object.othermethods = [
    "const custom_test_map* get_custom_tests() const { return NULL; }",
]
node_object.othermethods = [
    "void get_children(const_node_list& l) const {ambulant::lib::node_navigator<const ambulant::lib::node>::get_children(this, l);}", # XXX for now
    "void set_attributes(const char **attrs) { abort(); }", # XXX for now
]
node_factory_object.othermethods = [
	"ambulant::lib::node *new_node(const char *local_name, const char **attrs = 0, const ambulant::lib::node_context *ctx = 0) { abort(); return NULL; };",
	"ambulant::lib::node *new_node(const ambulant::lib::xml_string& local_name, const char **attrs = 0, const ambulant::lib::node_context *ctx = 0) { abort(); return NULL; };",
]
parser_factory_object.othermethods = [
    "ambulant::lib::xml_parser* new_parser(ambulant::lib::sax_content_handler*, ambulant::lib::sax_error_handler*) { abort(); return NULL; }", # XXX for now
]
xml_parser_object.othermethods = [
    "void set_content_handler(ambulant::lib::sax_content_handler*) { abort(); }", #XXXX
    "void set_error_handler(ambulant::lib::sax_error_handler*) { abort(); }", #XXXX
]
embedder_object.othermethods = [
    "void show_file(const ambulant::net::url& url) { ::system_embedder::show_file(url); }"
]

renderer_object.othermethods = [
    "void redraw(const ambulant::lib::rect&, ambulant::common::gui_window*) { abort(); }", # XXX
    "bool user_event(const ambulant::lib::point&, int) { abort(); return false; }", # XXXX
    "void transition_freeze_end(ambulant::lib::rect) { abort(); }", # XXX
]
bgrenderer_object.othermethods = [
    "void redraw(const ambulant::lib::rect&, ambulant::common::gui_window*) { abort(); }", # XXX
    "bool user_event(const ambulant::lib::point&, int) { abort(); return false; }", # XXXX
    "void transition_freeze_end(ambulant::lib::rect) { abort(); }", # XXX
]
surface_object.othermethods = [
    "ambulant::common::tile_positions get_tiles(ambulant::lib::size s, ambulant::lib::rect r) const { return surface::get_tiles(s, r); }",
]
surface_template_object.othermethods = [
    "void animated() { abort(); }", # XXX
]
animation_destination_object.othermethods = [
    "std::string get_name() const { return ::region_info::get_name(); }",
    "ambulant::lib::rect get_rect(const ambulant::lib::rect* dft=NULL) const { return ::region_info::get_rect(dft); }",
    "ambulant::common::fit_t get_fit() const { return ::region_info::get_fit(); }",
    "ambulant::lib::color_t get_bgcolor() const { return ::region_info::get_bgcolor(); }",
    "ambulant::common::zindex_t get_zindex() const { return ::region_info::get_zindex(); }",
    "bool get_showbackground() const { return ::region_info::get_showbackground(); }",
    "bool is_subregion() const { return ::region_info::is_subregion(); }",
    "double get_soundlevel() const { return ::region_info::get_soundlevel(); }",
    "ambulant::common::sound_alignment get_soundalign() const { return ::region_info::get_soundalign(); }",
    "ambulant::common::tiling get_tiling() const { return ::region_info::get_tiling(); }",
    "const char* get_bgimage() const { return ::region_info::get_bgimage(); }",
    "double get_bgopacity() const { return ::region_info::get_bgopacity(); }",
    "bool get_transparent() const { return ::region_info::get_transparent(); }",
    "double get_mediaopacity() const { return ::region_info::get_mediaopacity(); }",
    "double get_mediabgopacity() const { return ::region_info::get_mediabgopacity(); }",
    "ambulant::lib::rect get_crop_rect(const ambulant::lib::size& srcsize) const { return ::region_info::get_crop_rect(srcsize); }", # XXXX
    "const ambulant::common::region_dim_spec& get_region_panzoom(bool fromdom) const { abort(); static ambulant::common::region_dim_spec dummy; return dummy; }", # XXX
    "void set_region_panzoom(const ambulant::common::region_dim_spec& rds) { abort(); }",
	"bool is_chromakey_specified() const { return ::region_info::is_chromakey_specified(); }",
	"ambulant::lib::color_t get_chromakey() const { return ::region_info::get_chromakey(); }",
	"ambulant::lib::color_t get_chromakeytolerance() const { return ::region_info::get_chromakeytolerance(); }",
	"double get_chromakeyopacity() const { return ::region_info::get_chromakeyopacity(); }",
#    "ambulant::common::region_dim get_region_dim(const std::string&, bool = false) const { abort(); }",
#    "void set_region_dim(const std::string&, const ambulant::common::region_dim&) { abort(); }",
]
global_playable_factory_object.othermethods = [
    "bool supports(ambulant::common::renderer_select*) { abort(); return false; }",
    "ambulant::common::playable* new_playable(ambulant::common::playable_notification*, int, const ambulant::lib::node*, ambulant::lib::event_processor*) { abort(); return NULL; }", # XXX
    "ambulant::common::playable* new_aux_audio_playable(ambulant::common::playable_notification *context, int, const ambulant::lib::node *node, ambulant::lib::event_processor *evp, ambulant::net::audio_datasource *src) { abort(); return NULL; }", # XXX
]

global_state_component_factory_object.othermethods = [
    "ambulant::common::state_component* new_state_component(const char*) { abort(); return NULL; }", # XXX
]
datasource_object.othermethods = [
    "long add_ref() { return 1; }",
    "long release() { return 1;}",
    "long get_ref_count() const { return 1; }",
    "long get_bandwidth_usage_data(const char **resource) { return -1; }",
    "char *get_read_ptr() { abort(); return NULL; }", # XXX
]
#pkt_datasource_object.othermethods = [
#    "long add_ref() { return 1; }",
#    "long release() { return 1;}",
#    "long get_ref_count() const { return 1; }",
#    "char *get_read_ptr() { abort(); return NULL; }", # XXX
#    "long get_bandwidth_usage_data(const char **resource) { return -1; }",
#    "ambulant::net::datasource_packet get_packet() { abort(); return ambulant::net::datasource_packet(0, NULL, 0); }", # XXX
#]
event_processor_object.othermethods = [
    "void set_observer(ambulant::lib::event_processor_observer*) { abort(); }"
]

player_object.othermethods = [
    "long add_ref() { return 1; }",
    "long release() { return 1;}",
    "long get_ref_count() const { return 1; }",
    "char *get_read_ptr() { abort(); return NULL; }", # XXX
]

print "=== Generating C++->Python callback interfaces (.h file) ==="

# Generate the interface
SetOutputFileName(CXX2PYDECLFILE)
module.generateDeclaration()

print "=== Generating C++->Python callback implementation (.cpp file) ==="

# Generate the code
module.includestuff = """
#define CPP_TO_PYTHON_BRIDGE 1

#include "ambulantinterface.h"
#include "ambulantutilities.h"
#include "ambulantmodule.h"


// The Python interface does not qualify strings with const, so we have to
// disable warnings about non-writeable strings (zillions of them)

#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wwrite-strings"
#endif

extern PyObject *audio_format_choicesObj_New(const ambulant::net::audio_format_choices *itself);
extern int audio_format_choicesObj_Convert(PyObject *v, ambulant::net::audio_format_choices *p_itself);
"""
SetOutputFileName(CXX2PYFILE)
module.generate()
