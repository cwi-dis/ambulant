# This script generates a Python interface for an Apple Macintosh Manager.
# It uses the "bgen" package to generate C code.
# The function specifications are generated by scanning the mamager's header file,
# using the "scantools" package (customized for this particular manager).

import string
from bgen import *
from bgenCxxSupport import *
# Declarations that change for each manager
MODNAME = 'ambulant'                         # The name of the module

# The following is *usually* unchanged but may still require tuning
MODPREFIX = 'PyAm'                        # The prefix for module-wide routines
INPUTFILE = 'ambulantgen.py' # The file generated by the scanner
PY2CXXFILE = MODNAME + "module.cpp"       # The Python to C++ glue code
CXX2PYFILE = MODNAME + "interface.cpp"   # The C++ to Python glue code
CXX2PYDECLFILE = MODNAME + "interface.h"     # The C++ to Python declarations

# Create the type objects

includestuff = """
#define WITH_EXTERNAL_DOM 1
#include "ambulant/config/config.h"
#include "ambulant/version.h"
"""
execfile("ambulantincludegen.py")

includestuff = includestuff + """

#include "ambulantinterface.h"
#include "ambulantutilities.h"
#include "ambulantmodule.h"
"""

finalstuff = """
// Declare initambulant as a C external:

extern "C" void initambulant(); 
"""

initstuff = """
PyEval_InitThreads();
"""

variablestuff="""
"""

bool = OpaqueByValueType("bool", "bool")
size_t = Type("size_t", "l")
unsigned_int = Type("unsigned int", "l")
progress_type = Type("ambulant::lib::transition_info::progress_type", "d")
std_string = StdStringType()
xml_string = StdStringType("ambulant::lib::xml_string")
const_xml_string_ref = StdStringType("const ambulant::lib::xml_string&")
q_name_pair = StdPairType(xml_string, xml_string, "ambulant::lib::q_name_pair")
const_q_name_pair_ref = StdPairType(xml_string, xml_string, 
    "const ambulant::lib::q_name_pair&", "ambulant::lib::q_name_pair")
duration = StdPairType(bool, double, "ambulant::common::duration")

InBuffer = VarInputBufferType('char', 'size_t', 'l')
return_stringptr = Type("const char *", "s")  # ONLY FOR RETURN VALUES!!
output_stringptr = Type("char *", "s")  # BE CAREFUL!

# Ambulant-specific
net_url = OpaqueByRefType("ambulant::net::url", "ambulant_url")
screen_rect_int = OpaqueByRefType("ambulant::lib::screen_rect_int", "ambulant_screen_rect")
const_lib_screen_rect_int_ref = OpaqueByRefType("const ambulant::lib::screen_rect_int&", "ambulant_screen_rect")
rect = OpaqueByRefType("ambulant::lib::rect", "ambulant_rect")
point = OpaqueByRefType("ambulant::lib::point", "ambulant_point")
const_lib_point_ref = OpaqueByRefType("const ambulant::lib::point&", "ambulant_point")
size = OpaqueByRefType("ambulant::lib::size", "ambulant_size")
zindex_t = Type("ambulant::common::zindex_t", "l")
cookie_type = Type("ambulant::common::playable::cookie_type", "l")
const_cookie_type = cookie_type
color_t = Type("ambulant::lib::color_t", "l") # XXXX Split into RGB
event_priority = Type("ambulant::lib::event_processor::event_priority", "l")
timestamp_t = Type("ambulant::net::timestamp_t", "L")
time_type = Type("ambulant::lib::abstract_timer::time_type", "l")
tiling = Type("ambulant::common::tiling", "l")
fit_t = Type("ambulant::common::fit_t", "l")
sound_alignment = Type("ambulant::common::sound_alignment", "l")

# Our (opaque) objects

class MyGlobalObjectDefinition(CxxMixin, PEP253Mixin, GlobalObjectDefinition):

    def __init__(self, name, prefix, itselftype):
        GlobalObjectDefinition.__init__(self, name, prefix, itselftype)
        self.constructors = []
        
    def add(self, g, dupcheck=0):
        if g.name == self.name:
            g.setselftype(self.objecttype, self.itselftype)
            self.constructors.append(g)
            print "Adding constructor for", self.name
        else:
            GlobalObjectDefinition.add(self, g, dupcheck)
            
    def outputCheckNewArg(self):
        Output('if (itself == NULL)')
        OutLbrace()
        Output('Py_INCREF(Py_None);')
        Output('return Py_None;')
        OutRbrace()
        CxxMixin.outputCheckNewArg(self)
        # XXX Add refcount, if needed
        
    def outputCheckConvertArg(self):
        Output('if (v == Py_None)')
        OutLbrace()
        Output('*p_itself = NULL;')
        Output('return 1;')
        OutRbrace()
        CxxMixin.outputCheckConvertArg(self)
        
    def outputStructMembers(self):
        GlobalObjectDefinition.outputStructMembers(self)
        # XXX Output("bool owned;")
        
    def outputInitStructMembers(self):
        GlobalObjectDefinition.outputInitStructMembers(self)
        # XXX init owned, if needed
        
    def outputCleanupStructMembers(self):
        # XXX For refcounted objects decref
        # XXX For owned objects delete
        pass

    def outputCompare(self):
        Output()
        Output("static int %s_compare(%s *self, %s *other)", self.prefix, self.objecttype, self.objecttype)
        OutLbrace()
        Output("if ( self->ob_itself > other->ob_itself ) return 1;")
        Output("if ( self->ob_itself < other->ob_itself ) return -1;")
        Output("return 0;")
        OutRbrace()

    def outputHash(self):
        Output()
        Output("static int %s_hash(%s *self)", self.prefix, self.objecttype)
        OutLbrace()
        Output("return (int)self->ob_itself;")
        OutRbrace()

    def output_tp_newBody(self):
        Output("PyObject *_self;")
        Output()
        Output("if ((_self = type->tp_alloc(type, 0)) == NULL) return NULL;")
        Output("((%s *)_self)->ob_itself = NULL;", self.objecttype)
        ##Output("((%s *)self)->ob_freeit = CFRelease;", self.objecttype)
        Output("return _self;")

    def output_tp_initBody(self):
        Output("%s itself;", self.itselftype)
        Output("char *kw[] = {\"itself\", 0};")
        Output()
        for con in self.constructors:
            con.outputConstructorBody()
        Output("if (PyArg_ParseTupleAndKeywords(_args, _kwds, \"O&\", kw, %s_Convert, &itself))",
                self.prefix)
        OutLbrace()
        Output("((%s *)_self)->ob_itself = itself;", self.objecttype)
        Output("return 0;")
        OutRbrace()
        Output("return -1;")
        
# Create the generator groups and link them
module = CxxModule(MODNAME, MODPREFIX, includestuff, finalstuff, initstuff, variablestuff)
functions = []

execfile("ambulantobjgen.py")

# XXXX Temporarily disabled
methods_none_playable_factory = []

common_factories_ptr = ByAddressTupleType("ambulant::common::factories",
        (playable_factory_ptr, "rf"),
        (window_factory_ptr, "wf"),
        (datasource_factory_ptr, "df"),
        (global_parser_factory_ptr, "pf"))

# Some type synonyms
node_interface_ptr = node_ptr
lib_node_ptr = node_ptr
const_node_interface_ptr = const_node_ptr
methods_node_interface = methods_node

lib_event_processor_ptr = event_processor_ptr
ambulant_lib_event_processor_ptr = event_processor_ptr
abstract_event_processor_ptr = event_processor_ptr
methods_abstract_event_processor = methods_event_processor
lib_transition_info_ptr = transition_info_ptr

common_duration = duration
common_surface_ptr = surface_ptr
common_playable_ptr = playable_ptr
common_region_info_ptr = region_info_ptr
common_gui_window_ptr = gui_window_ptr
common_gui_events_ptr = gui_events_ptr
common_bgrenderer_ptr = bgrenderer_ptr
lib_document_ptr = document_ptr
lib_event_ptr = event_ptr
ambulant_lib_event_ptr = event_ptr
lib_abstract_timer_ptr = abstract_timer_ptr
timer_ptr = abstract_timer_ptr
lib_screen_rect_int = screen_rect_int
lib_point = point
lib_size = size
lib_color_t = color_t
lib_rect = rect
common_zindex_t = zindex_t
common_embedder_ptr = embedder_ptr
playable_notification_cookie_type = cookie_type
common_playable_notification_cookie_type = cookie_type
common_playable_notification_ptr = playable_notification_ptr
net_audio_datasource_ptr = audio_datasource_ptr
ambulant_net_url = net_url
const_ambulant_net_url_ref = net_url

# Do the type tests
execfile("ambulanttypetest.py")

# Create the generator classes used to populate the lists
Function = FunctionGenerator
Method = CxxMethodGenerator
ConstMethod = Method
ConstructorMethod = CxxConstructorGenerator

# Create and populate the lists

execfile(INPUTFILE)


# add the populated lists to the generator groups
# (in a different wordl the scan program would generate this)
for f in functions: module.add(f)

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# Resolve duplicates
module.resolveduplicates()

# ADD add forloop here

# generate output (open the output file as late as possible)
SetOutputFileName(PY2CXXFILE)
module.generate()

# Now we start to get really gross. We want to reuse as much as possible
# when generating the C++ wrapper classes around Python objects. So, we
# redefine MyGlobalObjectDefinition, create a new module based on the
# wrapper module, reread the object definitions file
# (which will then create a whole new set of objects based on the new baseclass
# and reinitialize the methodlists to be empty)
# and call generate on this new module. Poof! We have the interface
# the other way...
from bgenBackSupport import *
class BackVarInputBufferType(VarInputBufferType):
    
    def getAuxDeclarations(self, name):
        return []
        
    def mkvalueArgs(self, name):
        return "%s__in__, (int)%s__len__" % (name, name)

InBuffer = BackVarInputBufferType('char', 'long', 'l')

includestuff = """
#define WITH_EXTERNAL_DOM 1
"""
finalstuff = ""
execfile("ambulantincludegen.py")

class MyGlobalObjectDefinition(BackObjectDefinition):
    pass
    
class NoFunctionGenerator(FunctionGenerator):
    def generate(self):
        pass
        
    def setClass(self, name):
        pass
        
    def generateDeclaration(self):
        pass
        
    def checkreturnvar(self):
        pass
        
    def checkgenerate(self):
        return False
        
Function = NoFunctionGenerator
Method = BackMethodGenerator
ConstMethod = BackMethodGenerator
ConstructorMethod = NoFunctionGenerator

module = BackModule("pyambulant", includestuff, finalstuff)
functions = []
execfile("ambulantobjgen.py")
# Some type synonyms
node_interface_ptr = node_ptr
lib_node_ptr = node_ptr
const_node_interface_ptr = const_node_ptr
methods_node_interface = methods_node

lib_event_processor_ptr = event_processor_ptr
abstract_event_processor_ptr = event_processor_ptr
methods_abstract_event_processor = methods_event_processor

lib_event_ptr = event_ptr
lib_timer_ptr = abstract_timer_ptr
lib_abstract_timer_ptr = abstract_timer_ptr
lib_screen_rect_int = screen_rect_int
lib_point = point
lib_size = size
lib_color_t = color_t
lib_rect = rect
common_zindex_t = zindex_t
net_audio_datasource_ptr = audio_datasource_ptr

gui_window_object.baseconstructors.append("ambulant::common::gui_window(0)")

#import pdb ; pdb.set_trace()
execfile(INPUTFILE)

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# Dummy versions of methods we cannot support:
node_context_object.othermethods = [
    "const custom_test_map* get_custom_tests() const { return NULL; }",
]
node_object.othermethods = [
    "void get_children(const_node_list& l) const {}", # XXX for now
    "void append_data(const char *data, size_t len) { abort(); }", # XXX for now
    "void set_attributes(const char **attrs) { abort(); }", # XXX for now
]
parser_factory_object.othermethods = [
    "ambulant::lib::xml_parser* new_parser(ambulant::lib::sax_content_handler*, ambulant::lib::sax_error_handler*) { abort(); }", # XXX for now
]
xml_parser_object.othermethods = [
    "bool parse(const char*, long unsigned int, bool) { abort(); }", # XXX for now
    "void set_content_handler(ambulant::lib::sax_content_handler*) { abort(); }", #XXXX
    "void set_error_handler(ambulant::lib::sax_error_handler*) { abort(); }", #XXXX
]
embedder_object.othermethods = [
    "void show_file(const ambulant::net::url& url) { system_embedder::show_file(url); }"
]

renderer_object.othermethods = [
    "void redraw(const ambulant::lib::screen_rect_int&, ambulant::common::gui_window*) { abort(); }", # XXX
    "void user_event(const ambulant::lib::point&, int) { abort(); }", # XXXX
    "void transition_freeze_end(ambulant::lib::screen_rect_int) { abort(); }", # XXX
]
bgrenderer_object.othermethods = [
    "void redraw(const ambulant::lib::screen_rect_int&, ambulant::common::gui_window*) { abort(); }", # XXX
    "void user_event(const ambulant::lib::point&, int) { abort(); }", # XXXX
    "void transition_freeze_end(ambulant::lib::screen_rect_int) { abort(); }", # XXX
]
surface_object.othermethods = [
    "ambulant::lib::screen_rect_int get_fit_rect(const ambulant::lib::size&, ambulant::lib::rect*, const ambulant::common::alignment*) const { abort(); }", # XXX
]
surface_template_object.othermethods = [
    "void animated() { abort(); }", # XXX
]
global_playable_factory_object.othermethods = [
    "ambulant::common::playable* new_playable(ambulant::common::playable_notification*, int, const ambulant::lib::node*, ambulant::lib::event_processor*) { abort(); }", # XXX
]
datasource_object.othermethods = [
    "long add_ref() { return 1; }",
    "long release() { return 1;}",
    "long get_ref_count() const { return 1; }",
    "char *get_read_ptr() { abort(); return NULL;}", # XXX
]
# Generate the interface
SetOutputFileName(CXX2PYDECLFILE)
module.generateDeclaration()
# Generate the code
module.includestuff = """
#include "ambulantinterface.h"
#include "ambulantutilities.h"
#include "ambulantmodule.h"

"""
SetOutputFileName(CXX2PYFILE)
module.generate()
