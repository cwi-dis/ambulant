<!DOCTYPE html>
<html>
  <head>
    <title>Bar Chart</title>
    <script type="text/javascript" src="d3.js"></script>
    <style type="text/css">

body {
  font: 10px sans-serif;
}

g.bar rect.run {
  fill: #666666;
}

g.bar rect.fill {
  fill: #999999;
}

g.bar line {
	stroke: #666666;
}

g.playable line {
	stroke: #ffffff;
}

g.medianode rect.run {
  fill: #99cccc;
}

g.medianode rect.fill {
  fill: #ccffff;
}

g.prefetch rect.run {
  fill: #99cc00;
}

g.prefetch rect.fill {
  fill: #ccff00;
}

g.playable rect.run {
  fill: #cccc00;
}

g.playable rect.fill {
  fill: #ffff99;
}

g.playable rect.stall {
  fill: #ff3030;
}

.bar text.value {
  fill: red;
}

.axis {
  shape-rendering: crispEdges;
}

.axis path {
  fill: none;
}

.x.axis line {
  stroke: #fff;
  stroke-opacity: .8;
}

.y.axis path {
  stroke: black;
}

    </style>
  </head>
  <body>
    <form name="selections">
    	<input type="checkbox" name="show" value="medianode" checked="checked" onClick="regenShowAndGraph();">Media
    	<input type="checkbox" name="show" value="prefetch" checked="checked" onClick="regenShowAndGraph();">Prefetch
    	<input type="checkbox" name="show" value="playable" checked="checked" onClick="regenShowAndGraph();">Renderers
    	<input type="checkbox" name="show" value="*" checked="checked" onClick="regenShowAndGraph();">All the rest
    	<input type="button" value="zoomin time" onClick="zoom(1.414, 1.0);">
    	<input type="button" value="zoomout time" onClick="zoom(0.707, 1.0);">
    	<input type="button" value="larger nodes" onClick="zoom(1.0, 1.414);">
    	<input type="button" value="smaller nodes" onClick="zoom(1.0, 0.707);">
    	<input type="checkbox" name="autoreload" value="*" checked="checked" onClick="autoReloadChanged();">Auto-reload
    </form>
    <div id="graphlocation"></div>
    <script type="text/javascript">

var m = [30, 10, 10, 330],
    w = 960 - m[1] - m[3],
    h = 930 - m[0] - m[2];

var h_scale = 1.0;
var v_scale = 1.0;

var format = d3.format(",.1f");

var x = d3.scale.linear().range([0, w*h_scale]),
    y = d3.scale.ordinal().rangeRoundBands([0, h*v_scale], .1);

var xAxis = d3.svg.axis().scale(x).orient("top").tickSize(-h),
    yAxis = d3.svg.axis().scale(y).orient("left").tickSize(0);

var svg = d3.selectAll("div#graphlocation").append("svg")
	.attr("width", w*h_scale + m[1] + m[3])
	.attr("height", h*v_scale + m[0] + m[2])
	.append("g")
	.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

var showTypes = new Array();
showTypes["medianode"] = true;
showTypes["prefetch"] = true;
showTypes["playable"] = true;
showTypes["*"] = true;

svg.append("g")
	.attr("class", "x axis");

svg.append("g")
	.attr("class", "y axis");

genGraph = function(data) {

	// Select only the ones we want
	newData = [];
	for( var dataItemIndex in data) {
		var dataItem = data[dataItemIndex];
		var objType = dataItem.objtype;
		if (objType in showTypes) {
			if (showTypes[objType])
				newData.push(dataItem);
		} else {
			if (showTypes["*"])
				newData.push(dataItem);
		}
	}
	data = newData;
	
	// Parse numbers, and sort by value.
	data.forEach(function(d) { d.runs[0].start = +d.runs[0].start; d.runs[0].stop = +d.runs[0].stop; });
	// data.sort(function(a, b) { return b.start - a.start; });
	
	// Set the scale domain and ranges
	x.domain([0, d3.max(data, function(d) { return d.runs[0].stop; })]);
	y.domain(data.map(function(d) { return d.objid; }));
	var new_h = data.length * 3 * 10; // Number(getComputedStyle('graphlocation', '').fontSize.match(/(\d+)px/)[1]);
	// if (new_h < h) new_h = h;
	x.range([0, w*h_scale]);
	y.rangeRoundBands([0, new_h*v_scale], .1);
	console.log('width ' + w*h_scale + ' height ' + new_h*v_scale);
	d3.selectAll("div#graphlocation svg")
		.transition().duration(500)
		.attr("width", w*h_scale + m[1] + m[3])
		.attr("height", new_h*v_scale + m[0] + m[2]);
	
	// First set up the bars (rows). Do this separately for existing/new/deleted data.
	var bars = svg.selectAll("g.bar")
		.data(data, function(d) { return d.objid; })
	
	bars.transition().duration(500)
		.attr("transform", function(d) { return "translate(0," + y(d.objid) + ")"; });

	bars.enter().append("g")
		.attr("class", function(d) { return "bar"; })
		.classed("medianode", function(d) { return d.objtype == "medianode"; })
		.classed("playable", function(d) { return d.objtype == "playable"; })
		.classed("prefetch", function(d) { return d.objtype == "prefetch"; })
		.attr("transform", function(d) { return "translate(0," + y(d.objid) + ")"; })
		
		.append("line")
		.attr("x1", -10)
		.attr("x2", 10)
		.attr("y1", 0)
		.attr("y2", 0);
		
	bars.exit().remove();

	// Next, set up the grouped data (runs) within a horizontal bar. Again existing/new/removed.
	var rungroup = bars.selectAll("g.rungroup")
		.data(function(d) { return d.runs; });
	
	rungroup.selectAll("rect.run")
		.transition().duration(500)
		.attr("x", function(d) { return x(d.start); })
		.attr("width", function(d) { return x(d.stop-d.start); })
		.attr("height", y.rangeBand());

	rungroup.selectAll("rect.fill")
		.transition().duration(500)
		.attr("x", function(d) { return x(d.fill); })
		.attr("width", function(d) { return x(d.stop-d.fill); })
		.attr("height", y.rangeBand());
		
	rungroup.selectAll("text")
		.transition().duration(500)
		.attr("x", function(d) { return x(d.start); })
		.attr("y", y.rangeBand() / 2)
		
	var newrungroup = rungroup.enter()
		.append("g")
		.attr("class", "rungroup");
		
	rungroup.exit().remove();

	// Now for all the new rungroups, create the active/postactive bars and the text field.
	newrungroup.append("rect")
		.attr("class", "run")
		.attr("x", function(d) { return x(d.start); })
		.attr("width", function(d) { return x(d.stop-d.start); })
		.attr("height", y.rangeBand());
	  
	newrungroup.append("rect")
		.attr("class", "fill")
		.attr("x", function(d) { return x(d.fill); })
		.attr("width", function(d) { return x(d.stop-d.fill); })
		.attr("height", y.rangeBand());
	
	newrungroup.append("text")
		.attr("class", "value")
		.attr("x", function(d) { return x(d.start); })
		.attr("y", y.rangeBand() / 2)
		.attr("dx", 3)
		.attr("dy", ".35em")
		.text(function(d) { return d.descr; });
	
	var stallgroup = bars.selectAll("g.stallgroup")
		.data(function(d) { if ("stalls" in d) return d.stalls; return []; });
		
	stallgroup.selectAll("rect.stall")
		.transition(500)
		.attr("x", function(d) { return x(d.start); })
		.attr("width", function(d) { return x(d.stop-d.start); })
		.attr("height", y.rangeBand()/6);
		
	var newstallgroup = stallgroup.enter()
		.append("g")
		.attr("class", "stallgroup");
		
	stallgroup.exit().remove();
	
	newstallgroup.append("rect")
		.attr("class", "stall")
		.attr("x", function(d) { return x(d.start); })
		.attr("width", function(d) { return x(d.stop-d.start); })
		.attr("height", y.rangeBand()/6);
	  
	
	// Finally setup the axes for the whole graph
	svg.select("g.x.axis")
		.call(xAxis);
	
	svg.select("g.y.axis")
		.call(yAxis);
}

regenGraph = function() {
	d3.text("data.json", "text/json", function(text) {
		genGraph(eval('(' + text + ')'))
		});
};

regenShowAndGraph = function() {
	for (var i=0; i < document.selections.show.length; i++) {
		showTypes[document.selections.show[i].value] = document.selections.show[i].checked;
	}
	regenGraph();
};

zoom = function(yfactor, xfactor) {
	h_scale *= yfactor;
	v_scale *= xfactor;
	regenGraph();
};

regenGraph();

var interval = setInterval("regenGraph()", 1000);
autoReloadChanged = function() {
	if (interval) clearInterval(interval);
	if (document.selections.autoreload.value) {
		interval = setInterval("regenGraph()", 1000);
	}
}
    </script>
  </body>
</html>
