<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>Ambulant design, overall</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="ambulant-design-overall">
<h1 class="title">Ambulant design, overall</h1>
<div class="section" id="jack-jansen-23-june-03">
<h1><a name="jack-jansen-23-june-03">Jack Jansen, 23-June-03</a></h1>
<p>Here are some general (unstructured) thoughts on the Ambulant design.</p>
</div>
<div class="section" id="design-process">
<h1><a name="design-process">Design process</a></h1>
<p>The design is going to consist of a mixed bag of technologies:</p>
<ul class="simple">
<li>Text files such as this one for informal descriptions.</li>
<li>C++ header files for class definitions and such.</li>
<li>Image files for UML pictures.</li>
<li>XXXX (Kleanthis: please check this sentence) more formal text documents
as explained in sdd-schema.txt.</li>
</ul>
<p>The design is going to be done in C++, but we will try to keep it compatible
with Java or Python, and if possible keep cross-language implementations
possible.  This would not
only benefit people extending it in the long run, but could also jump-start
the initial implementation by re-using the existing GRiNS scheduler.</p>
<p>Boost.python was considered as a way to achieve C++/Python interoperability, but
it turns out it is too heavyweight. SWIG is a possible alternative,
or (for Python) a SWIG/Bgen hybrid.</p>
</div>
<div class="section" id="terminology">
<h1><a name="terminology">Terminology</a></h1>
<p>We need to settle on terminology for use in the design documentation. There
are various terms (&quot;event&quot; and &quot;scheduler&quot; come to mind) that could mean four
or more different things in our context.</p>
<p>We need a term for &quot;stateless from an external point of view&quot;. There are
various objects such as data sources that do have lots of internal state
(such as caching information) but appear immutable/stateless from the outside.</p>
</div>
<div class="section" id="source-code-conventions">
<h1><a name="source-code-conventions">Source code conventions</a></h1>
<p>Here's a somewhat random list of source code conventions that we have decided
to use (at least: Jack thinks this has been decided, please fix if you disagree):</p>
<ul class="simple">
<li>Indent 4 spaces, with the following exceptions:<ul>
<li>namespace doesn't indent at all</li>
<li>public:, private: and such indent two spaces</li>
</ul>
</li>
<li>no camelCase, CamelCase or Capitalization in class or variable names</li>
<li>Underscores to delimit words</li>
<li>attribute names start with &quot;m_&quot;</li>
<li>we have a toplevel namespace ambulant, with a second level of namespaces
under that</li>
<li>semi-private classes go into into a namespace named &quot;detail&quot;.</li>
<li>Template type parameters start with an upper case letter
(as in: <tt class="literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">A&gt;</span> <span class="pre">{}</span></tt>)</li>
</ul>
</div>
<div class="section" id="global-structure">
<h1><a name="global-structure">Global structure</a></h1>
<p>The global structure needs some thought. If we want to be able to use the code
to create, say, a plugin SMIL renderer for use in a browser we need a global
&quot;playback engine&quot; object that has all the others hanging off it (plus factory
methods to create them, etc). There will be a performance penalty to this, but
I don't think it's too big. If we have this global object we might as well
subclass all the children of this object from a common base class that handles
the global administration, and the global object could hold things like
memory allocators, stderr, etc.</p>
<blockquote>
<em>QUESTION</em>: is there a way we could handle the memory allocator transparently?
With things like stdout I think we can (put a member &quot;cout&quot; in our object
base class, make it always refer to the &quot;cout&quot; in the playback engine), but
for memory allocators I don't know whether we can break into C++'s new operator.
This may be important if we want to embed our player, as the embedder may
hand us a memory allocator to use.</blockquote>
<p>With a structure like this the application itself becomes basically a skeleton
embedder: it is responsible for the GUI, handling open/open URL/quit/etc, it creates
playback engine objects when needed and has a small number of callbacks for
&quot;create window&quot; and such.</p>
</div>
<div class="section" id="run-time-system">
<h1><a name="run-time-system">run-time system</a></h1>
<p>A point of concern is garbage collection. Because we want to do a C++ implementation
we cannot rely on refcounting or garbage collection in the underlying runtime.
lib/refcount.h has a simple refcounting implementation that we could use for
garbage collection.</p>
<blockquote>
XXXX The refcounting implementation may interfere with any cross-language plans.</blockquote>
<p>We need to decide on a per-case basis whether we need refcounting or whether auto_ptr
or plain pointers are more appropriate. Here's some prose by KK that should
be incorporated here:</p>
<blockquote>
I think that ref-counting should be used when it is absolutely needed
(proven to be needed). It adds an overhead and some complexity since it can
not happen automatically. On the other hand there are some cases where it
simplifies the code  a lot. If I judge from my code and the code of others I
have seen, only very few objects need ref counting. First, objects owned by
a class, and quite all are, never need to be ref counted. You either use
auto_ptr or just delete them. The auto_ptr may be used more extensively but
also most of the times plain pointers can do the job. I think that
ref-counting is needed when objects containing references are shared by
completely independent components. For example you have a processor object
with a queue and other application objects submit work items to this queue
AND the work items contain references to objects that must be available when
the work item is executed. If the work items are self-contained or are
shallow enough to make them self-contained, then you don't need
ref-counting.</blockquote>
<p>The architecture is going to be fairly tightly coupled. The original idea
of allowing the high-level scheduler to live on a different machine, precomputing
schedules and ending these to a low level scheduler, isn't going to work
for SMIL without putting almost all SMIL complexity in the low-level scheduler.</p>
<blockquote>
XXXX Outcome of the May 21 meeting is that we should be able to do the design
in such a way that we can allow for a split. For this, we need to de-couple
the HL-scheduler from the event processor and run it in a separate thread.
The only communication between HL-scheduler and the rest of the system are
downcalls to install timelines and upcalls to signal that user interaction has
happened. What we do need to investigate is whether it is then still possible
to use the Data Source objects from the scheduler, and/or whether special
measures are needed for that.</blockquote>
</div>
<div class="section" id="main-loop">
<h1><a name="main-loop">main loop</a></h1>
<p>The basic architecture is going to be event-driven. The alternative
is to use multiple threads all over, but it seems event-driven is the better
choice. An object that wants to use multiple threads can do so more easily
on an event infrastructure than the other way around, but these threads are
&quot;somebody else's problem&quot;, as they are hidden from the rest of the architecture.</p>
<p>We do want to allow the option (probably compile time) to allow multiple worker
threads to handle the events. This should be a compile time option, so we don't
incur the overhead of locking the event mgr data structures if there's only a
single worker thread.</p>
<p>Also, although it seems at first glance that some objects, such as a renderer,
would benefit from a threaded architecture it turns out this isn't really so.
The naive threaded implementation:</p>
<pre class="literal-block">
while data = read_data():
    render_data(data)
</pre>
<p>will not work, because many other things can also happen, such as a user-initiated
event, or the timeline for the renderer being torn down. So, the naive loop
sketched here will become hairy anyway, and look like:</p>
<pre class="literal-block">
while event = wait_for_some_interesting_event():
        switch event:
                case DATA: render_data(data)
                case STOP: close_resources_and_exit()
                ...
</pre>
<p>so we might as will split this out in the architecture.</p>
<p>The event handler architecture needs an elaborate priority scheme, that is expressive
enough that the best execution order of things that happen &quot;at the same time&quot;
is automatic.</p>
<p>A problem with the event handler is how to represent an event callback.
lib/callback.h has a solution for this.</p>
<p>If possible we should design the data structures and API such that a shortcut can be
taken (if A schedules a callback for B and nothing of higher priority is runnable then
we call B directly in stead of going through the callback main loop).</p>
</div>
<div class="section" id="integrating-third-party-tools">
<h1><a name="integrating-third-party-tools">integrating third-party tools</a></h1>
<p>We need to be able to use existing toolkits that take work out of our hands.
Think of QuickTime and DirectX, where you basically pass a URL and say &quot;play&quot; and
have nothing to worry about anymore. Also, existing URL access libraries (such
as the caching infrastructure on windows) and a third party RTSP library need
to be used. This also means we don't have to handle firewalls and what more.
Investigating toolkits we can use needs to be done early, as it may influence
some of the other design issues (GC, event model).</p>
<p>remarks.txt lists options we have for XML parsers, SAX/DOM, regex and RTP/RTSP toolkits.</p>
<p>We need to be able to re-use existing (Explorer, Netscape) plugins, when applicable.</p>
</div>
<div class="section" id="scheduler">
<h1><a name="scheduler">scheduler</a></h1>
<p>The scheduler is going to be split in two. There is a high-level language
dependent scheduler and a low-level independent one. We will write a SMIL
high level scheduler, other people should be able to replace that with, say,
a QuickTime or MPEG-4 scheduler while re-using the low-level scheduler.</p>
<p>The Low-level scheduler is going to be based on fixed timelines. The HL
scheduler identifies a portion of the SMIL document that it can fit on a fixed
timeline (at least: a fully ordered linear timeline), it creates a schedule for this
and pushes it down. These low-level schedules look somewhat like a petri-net,
but they probably need &quot;or&quot; in addition to &quot;and&quot;. The LL schedule will contain
events that trigger the HL scheduler when needed (such as when the user clicks
a link, or when the schedule finishes). These timelines are what I referred to
in the past as &quot;multimedia basic blocks&quot;. A description of what these timelines
look like is in the file timelines.txt.</p>
<p>The elements in the timeline need enough information to be able to get back at
a HL object from them, so we do the annotation thing. Also, we need to be able
to get from the HL object tree to the timeline objects too, so that hyperjumps
can clear out the relevant timelines.</p>
<p>Timeline schedules are completely independent, at their level. If one timeline
kills or pauses another one this happens because it sends an event to the
HL scheduler which does the killing or pausing. It may be that timelines can
share a clock (or, probably better, that the clock in a timeline can be slaved
to the clock in another timeline).</p>
<p>I think there are always going to be situations where we want to &quot;restart the world&quot;,
i.e. stop everything, tell the highlevel scheduler where we are and let it re-create
the lowlevel schedules to put us back where we were before the restart (but respecting
the new situation that caused the restart). Situations that come to mind are a resize
of the playback window, UI changes like turing on subtitles or other system-test
attributes, etc. We could probably solve each of these cases without restarting,
but if we have the mechanism to do a restart (and do it without too much impact
on the user experience) it can be used as a fallback mechanism, and speed up
initial implementation.</p>
</div>
<div class="section" id="coupling-between-high-and-low-level">
<h1><a name="coupling-between-high-and-low-level">Coupling between high and low level</a></h1>
<p>This section is here because I don't know where else to put it. Something that
struck me is that there are a couple of objects that are really one-one mappings
of SMIL nodes at different levels. Specifically, the renderer object is the SMIL
node at the timeline level. Also, it seems that if we decide to always create
a subregion when playing a node there might also be a 1-1 mapping here.</p>
<p>Could we somehow take these three objects and make them &quot;live together&quot; for
efficiency reasons? What I would like is three distinct interfaces but all living
in the same object. At least, optionally: if we at some point decide to do
the decoupled player the objects will become distinct.</p>
<p>But maybe we are good enough off initially by specifying in the UML that this
1-1 relationship exists, and put off any optimization until later.</p>
</div>
<div class="section" id="missing">
<h1><a name="missing">Missing</a></h1>
<p>Here is a list of bits of the design that I know are missing:</p>
<ul class="simple">
<li>What events are accepted by what objects, and what the arguments are.</li>
<li>How we handle anchors. Maybe treat as nodes?</li>
<li>How we handle transitions. Maybe also treat as nodes? We probably shouldn't
follow the SMIL model too closely, as its transitions are a bit funny.</li>
<li>How we handle subregions. Maybe the same as normal regions, but created dynamically?
Or are they simply a part of the renderer objects?
Does this influence anchors too? Do regions belong to a timeline?</li>
<li>How we handle SMIL animation. This needs to be done in a way that doesn't
require restarting the world.</li>
</ul>
</div>
</div>
</body>
</html>
