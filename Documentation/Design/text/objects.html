<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.7: http://docutils.sourceforge.net/" />
<title>Ambulant design, main objects</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="ambulant-design-main-objects">
<h1 class="title">Ambulant design, main objects</h1>
<!-- This document is prepended when we generate HTML. It contains the links
used by the other documents, implemented as hyperlinks. An alternative
head document is available for LaTeX generation. -->
<a class="target" id="objects-section" name="objects-section"></a><p>Last updated for Ambulant version 1.1.</p>
<div class="section" id="introduction">
<h1><a name="introduction">Introduction</a></h1>
<p>This document describes the function of various of the more important
objects and interfaces in the Ambulant Player. If you haven't already done
so it is probably a good idea to first read the <a class="reference" href="overall.html">Overall design</a> and 
<a class="reference" href="walkthrough.html">walkthrough</a> documents. The first one explains the design principles and
some of the choices made, the second one is a brief walkthrough of how the
player loads, parses and plays a SMIL document.</p>
<p>The nitty-gritty details of these objects, on a level interesting to
developers, are available too, in the <a class="reference" href="../../API/html/index.html">API documentation</a>. This document
may need to be regenerated, see the README file in the <a class="reference" href="../..">documentation
directory</a> if it doesn't seem to exist.</p>
</div>
<div class="section" id="ambulantplayer-interfaces">
<h1><a name="ambulantplayer-interfaces">AmbulantPlayer interfaces</a></h1>
<ul class="simple">
<li><a class="reference" href="#refcounting-protocol">Refcounting protocol</a>. A lowlevel interface shared by many objects.</li>
<li><a class="reference" href="#player-interface">Player Interface</a>. This is the toplevel object.</li>
<li><a class="reference" href="#parser-interface">Parser Interface</a>. Describes the interfaces to the XML parser.</li>
<li><a class="reference" href="#datasource-interface">Datasource interface</a>. The interface used to get external data into the program.</li>
<li><a class="reference" href="#playable-interface">Playable interface</a>. This interface makes media items appear on the screen.</li>
<li><a class="reference" href="#layout-interface">Layout interface</a>. This interface is used to determine where those media
items show up.</li>
<li><a class="reference" href="#gui-window-interface">GUI window interface</a>. This interface is used to create new windows.</li>
<li><a class="reference" href="#animation-interface">Animation interface</a>. The interface used for SMIL animation.</li>
</ul>
</div>
<div class="section" id="ambulantplayer-objects">
<h1><a name="ambulantplayer-objects">AmbulantPlayer Objects</a></h1>
<ul class="simple">
<li><a class="reference" href="#clocks">Clocks</a>. These advance a virtual time.</li>
<li><a class="reference" href="#event-processor">Event processor</a>. This is the mainloop plus the event/callback mechanism.</li>
<li><a class="reference" href="#document">Document</a>. The representation of a SMIL document.</li>
<li><a class="reference" href="#node">Node</a>. The representation of the DOM tree.</li>
<li><a class="reference" href="#transitions">Transitions</a>. Classes to do visual transitions.</li>
<li><a class="reference" href="timeline.html">Timeline</a>. This is a description of another scheduler: the MMS scheduler.
This scheduler has a much simpler structure than the SMIL 2.0 scheduler.</li>
</ul>
<p>You may notice that the core of the player, the SMIL 2.0 scheduler, is not
mentioned here. Unfortunately it is not documented yet.</p>
<p>There are also additional low-level objects like <tt class="docutils literal"><span class="pre">thread</span></tt> and <tt class="docutils literal"><span class="pre">critical_section</span></tt>
that are not described here. See the <a class="reference" href="../../API/html/index.html">API documentation</a> for details.</p>
</div>
<div class="section" id="refcounting-protocol">
<h1><a name="refcounting-protocol">Refcounting protocol</a></h1>
<p>The <cite>refcounting protocol</cite> is contained in the file <tt class="docutils literal"><span class="pre">lib/refcount.h</span></tt>. It needs to
be implemented only by objects that are truly shared, i.e. any object whose
lifetime is not predetermined by some other object. New instances of refcounted
objects are created using the operator new. Any object that needs to share
a particular instance calls <tt class="docutils literal"><span class="pre">add_ref()</span></tt> against this instance. The creator
of the refcounted object and any sharer are responsible to call the <tt class="docutils literal"><span class="pre">release()</span></tt>
method of the object when they don't need the object any more.</p>
</div>
<div class="section" id="player-interface">
<h1><a name="player-interface">Player Interface</a></h1>
<p>The player is the top-level object. When it is created you pass a DOM tree,
a <tt class="docutils literal"><span class="pre">factories</span></tt> structure containing references to the <tt class="docutils literal"><span class="pre">playable_factory</span></tt>,
<tt class="docutils literal"><span class="pre">datasource_factory</span></tt> and <tt class="docutils literal"><span class="pre">window_factory</span></tt> and an embedder object used for
callbacks to the GUI (on state changes, opening of external documents, etc).</p>
<p>There is a <a class="reference" href="../models/player.pdf">UML diagram for player</a> showing how the player relates to various other objects.</p>
</div>
<div class="section" id="player-implementations">
<h1><a name="player-implementations">Player implementations</a></h1>
<p>There are currently two implementations of the player interface: <tt class="docutils literal"><span class="pre">smil_player</span></tt> and
<tt class="docutils literal"><span class="pre">mms_player</span></tt>. The first one is the all-singing-all-dancing SMIL 2.0 player,
the second one can play MMS documents, which use a very restricted subset of SMIL 1.0.</p>
<p>A concise walkthrough of how the <tt class="docutils literal"><span class="pre">smil_player</span></tt> operates is given in the <a class="reference" href="walkthrough.html">walkthrough</a>
document.</p>
</div>
<div class="section" id="parser-interface">
<h1><a name="parser-interface">Parser interface</a></h1>
<p>The XML parser roughly follows a SAX interface. To use it you provide it with objects
having the <tt class="docutils literal"><span class="pre">sax_content_handler</span></tt> and <tt class="docutils literal"><span class="pre">sax_error_handler</span></tt> interfaces. You then
feed your document to the parser and it will call back through those interfaces.</p>
<p>There is a <a class="reference" href="../models/parser.pdf">UML diagram for parser</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="parser-implementations">
<h1><a name="parser-implementations">Parser implementations</a></h1>
<p>There are currently two parser implementations, <tt class="docutils literal"><span class="pre">expat_parser</span></tt> uses James Clark's
<cite>expat</cite> parser, which is a fast and lean no-frills parser. <tt class="docutils literal"><span class="pre">xerces_parser</span></tt> uses
the Apache <cite>Xerces</cite> library, which is at the other extreme of the spectrum: it can do
document validation with both DTDs and Schemas and lots of other wonderful things. But
this comes at the price of a rather hefty memory footprint.</p>
</div>
<div class="section" id="datasource-interface">
<h1><a name="datasource-interface">Datasource interface</a></h1>
<p>There are actually a couple of these interfaces, but they are similar. Their function
is to implement URL retrieval schemes or file I/O and get external data to media
handlers and other modules requiring data access.</p>
<p>The general interface is that a datasource is acquired through a <tt class="docutils literal"><span class="pre">datasource_factory</span></tt>
interface, which passes the URL to the various implementations until one is found that
can handle it and returns a <tt class="docutils literal"><span class="pre">datasource</span></tt> object. The client then calls the <tt class="docutils literal"><span class="pre">start</span></tt>
method on this object, passing a callback routine, and the datasource will arrange for the
callback to be called as soon as data is available. No new callbacks will be done
until a new call to <tt class="docutils literal"><span class="pre">start()</span></tt> is made, and the datasource has a buffer that can be limited,
so this design allows for flow control over the net, if required.</p>
<p>There are specialised datasource interfaces for audio and video, that can handle extra things
like converting audio from mp3 format to linear samples, or demultiplexing an audio/video
stream.</p>
<p>There is a <a class="reference" href="../models/datasource.pdf">UML diagram for datasource</a> showing how these classes relates to each other.</p>
<p>There is also a <a class="reference" href="../models/datasource_state.pdf">UML state diagram for datasource</a> showing the state machine that a
datasource should adhere to.</p>
</div>
<div class="section" id="playable-interface">
<h1><a name="playable-interface">Playable interface</a></h1>
<p>The <tt class="docutils literal"><span class="pre">playable</span></tt> interface is implemented by what are usually called a media handlers
or media renderers: it is this interface the scheduler uses to make things appear
on the screen (or sound out of the speakers, or otherwise do their thing).</p>
<p>Playables are created through <tt class="docutils literal"><span class="pre">global_playable_factory</span></tt>, which has references to
all playable implementations and asks them in order whether they can handle playback
of this specific DOM node, until one matches.</p>
<p>When the playable is started it is provided with a <tt class="docutils literal"><span class="pre">playable_notification</span></tt> object
(implemented by the scheduler), which is where it can send its status messages (such
as <tt class="docutils literal"><span class="pre">stopped()</span></tt> when the media is finished, or <tt class="docutils literal"><span class="pre">clicked()</span></tt> when the user clicks the mouse
over the media item).</p>
<p>Most playables have an accompanying interface, <tt class="docutils literal"><span class="pre">renderer</span></tt>, which controls where the
media item is rendered (non-rendering items such as SMIL animations are the exception
to this rule).</p>
<p>There is a <a class="reference" href="../models/playable.pdf">UML diagram for playable</a> showing how these classes relates to each other.</p>
<p>There is also a <a class="reference" href="../models/playable_state.pdf">UML state diagram for playable</a> showing the state machine that a
playable should adhere to.</p>
</div>
<div class="section" id="playable-implementations">
<h1><a name="playable-implementations">Playable implementations</a></h1>
<p>While some media handlers implement the playable from scratch (an example is the
aforementioned SMIL animation handler) there are a number of convenience classes
that implement functionality shared by many media handlers. These are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">playable_imp</span></tt> which handles some bookkeeping having to do with the <tt class="docutils literal"><span class="pre">playable_notification</span></tt>
and <tt class="docutils literal"><span class="pre">event_processor</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">renderer_playable</span></tt> which augments that with a <tt class="docutils literal"><span class="pre">renderer</span></tt> interface and the
bookkeeping required for that.</li>
<li><tt class="docutils literal"><span class="pre">renderer_playable_ds</span></tt> which adds <tt class="docutils literal"><span class="pre">datasource</span></tt> creation and bookkeeping to that.</li>
<li><tt class="docutils literal"><span class="pre">renderer_playable_dsall</span></tt> which builds on that again and collects all data before
requiring further action.</li>
</ul>
<p>There is a <a class="reference" href="../models/renderer.pdf">UML diagram for renderer_playable</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="layout-interface">
<h1><a name="layout-interface">Layout interface</a></h1>
<p>The layout manager determines where media items appear, and also governs things like
z-ordering, background colors for regions and such.</p>
<p>The central interface is the <tt class="docutils literal"><span class="pre">surface</span></tt>, which is the object passed to a <tt class="docutils literal"><span class="pre">renderer</span></tt>.
Whenever a renderer has something new to show it calls <tt class="docutils literal"><span class="pre">need_redraw()</span></tt> on this
interface. Whenever it is time to actually redraw something the <tt class="docutils literal"><span class="pre">surface</span></tt> calls
<tt class="docutils literal"><span class="pre">redraw()</span></tt> on the <tt class="docutils literal"><span class="pre">renderer</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">layout_manager</span></tt> interface maps DOM nodes to the <tt class="docutils literal"><span class="pre">surface</span></tt> objects on which they
should play back.</p>
<p>There are two more auxiliary interfaces that are not strictly necessary but used
by the layout implementation for historical reasons: <tt class="docutils literal"><span class="pre">surface_template</span></tt> 
and <tt class="docutils literal"><span class="pre">surface_factory</span></tt>. These interfaces are used to create subregions and toplevel
windows, respectively.</p>
<p>There is a <a class="reference" href="../models/layout.pdf">UML diagram for layout</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="layout-implementation">
<h1><a name="layout-implementation">Layout implementation</a></h1>
<p>The SMIL 2.0 implementation of <tt class="docutils literal"><span class="pre">surface</span></tt>, <tt class="docutils literal"><span class="pre">surface_template</span></tt> and <tt class="docutils literal"><span class="pre">surface_factory</span></tt>
are the classes <tt class="docutils literal"><span class="pre">passive_region</span></tt> and <tt class="docutils literal"><span class="pre">passive_root_layout</span></tt>.</p>
<p>There is a <a class="reference" href="../models/region.pdf">UML diagram for region</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="gui-window-interface">
<h1><a name="gui-window-interface">GUI window interface</a></h1>
<p>This is the abstract interface used to create new windows and tie them to the
layout implementation. The implementation is machine-dependent, obviously, and usually
supplied by the hosting application.</p>
<p>In addition there is the <tt class="docutils literal"><span class="pre">gui_events</span></tt> interface which goes the other way:
it is exposed by the layout implementation, and used by the machine dependent
window implementation to communicate things like redraw requests.</p>
<p>There is a <a class="reference" href="../models/windows.pdf">UML diagram for window</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="animation-interface">
<h1><a name="animation-interface">Animation interface</a></h1>
<p>The animation interfaces are <tt class="docutils literal"><span class="pre">animation_destination</span></tt> and <tt class="docutils literal"><span class="pre">animation_notification</span></tt>.
The SMIL 2.0 playable uses these interfaces to change parameters and send notification
of those changes, respectively.</p>
<p>There is a <a class="reference" href="../models/animation.pdf">UML diagram for animation</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="clocks">
<h1><a name="clocks">Clocks</a></h1>
<p>All clocks adhere to the <tt class="docutils literal"><span class="pre">abstract_timer</span></tt> interface. This interface
allows you to get the current time and set the speed of the clock.</p>
<p>There is a companion interface <tt class="docutils literal"><span class="pre">abstract_timer_client</span></tt> (which is actually
a base class of <tt class="docutils literal"><span class="pre">abstract_timer</span></tt>) that allows objects to get notification
of changes in timer speed.</p>
<p>Currently there are two implementations of the <tt class="docutils literal"><span class="pre">abstract_timer</span></tt> interface:
the operating-system specific realtime clock (of which you cannot set the
speed) and <tt class="docutils literal"><span class="pre">timer</span></tt>, which implements a new zero-based clock
based on another <tt class="docutils literal"><span class="pre">abstract_timer</span></tt>. Its speed is settable
with <tt class="docutils literal"><span class="pre">set_speed</span></tt>, but it is tightly synchronized with its parent clock.</p>
<p>Eventually there may be other implementations of <tt class="docutils literal"><span class="pre">timer</span></tt>,
such as clocks that are allowed to slip synchronization and other such
semantics as required by SMIL.</p>
<p>There is a <a class="reference" href="../models/clocks.pdf">UML diagram for clocks</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="event-processor">
<h1><a name="event-processor">Event processor</a></h1>
<p>The <tt class="docutils literal"><span class="pre">event_processor</span></tt> is the low-level scheduler of the system. It is a
priority runqueue with methods to add callbacks, with an optional delay until
the callback becomes elegible.</p>
<p>There is a <a class="reference" href="../models/event_processor.pdf">UML diagram for event processor</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="document">
<h1><a name="document">Document</a></h1>
<p>The <tt class="docutils literal"><span class="pre">document</span></tt> class contains the DOM tree and some auxiliary data:</p>
<ul class="simple">
<li>the <tt class="docutils literal"><span class="pre">node_context</span></tt> which can be used to lookup nodes by XML ID and to
resolve relative URLs, and</li>
<li>the <tt class="docutils literal"><span class="pre">nscontext</span></tt> which stores information on the use of XML namespaces.</li>
</ul>
<p>There is a <a class="reference" href="../models/document.pdf">UML diagram for document</a> showing how the document class relates to various other objects.</p>
</div>
<div class="section" id="node">
<h1><a name="node">Node</a></h1>
<p>The <tt class="docutils literal"><span class="pre">node</span></tt> class represents a node in the DOM tree. Actually, our tree isn't
100% compatible with DOM, but close enough. The <tt class="docutils literal"><span class="pre">node</span></tt> objects store the tag,
attributes and data pertaining to the XML node. There are basic methods
to access the parent, next sibling and first child, to insert or remove nodes into a tree
and more.</p>
<p>In the actual code there is a compile-time switch <tt class="docutils literal"><span class="pre">WITH_EXTERNAL_DOM</span></tt> that governs
whether the <tt class="docutils literal"><span class="pre">node</span></tt> class is abstract or not. If defined, <tt class="docutils literal"><span class="pre">node</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">node_interface</span></tt>, the abstract API, and <tt class="docutils literal"><span class="pre">node_impl</span></tt> is one possible
implementation of it. If not defined <tt class="docutils literal"><span class="pre">node</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">node_impl</span></tt>, which
leads to a more efficient implementation with inline methods and such. This
helps on low-power machines.</p>
<p>There are two auxiliary classes that augment the node functionality using only
these interfaces:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">node_navigator</span></tt> uses the basic <tt class="docutils literal"><span class="pre">up()/down()/next()</span></tt> methods of node to
build more complex navigation.</li>
<li><tt class="docutils literal"><span class="pre">node_iterator</span></tt> is an iterator that allows you to iterate over a subtree.</li>
</ul>
<p>There is a <a class="reference" href="../models/node.pdf">UML diagram for node</a> showing how these classes relates to each other.</p>
</div>
<div class="section" id="transitions">
<h1><a name="transitions">Transitions</a></h1>
<p>The implementation of SMIL transitions is fairly complex, because there are very
many transition types and they also need to be implemented efficiently on
multiple platforms. The current implementation is fully based on inheritance,
a model with delegation would probably result in a cleaner design.</p>
<p>The central object is the <tt class="docutils literal"><span class="pre">transition_engine</span></tt>, which also supplies to interface
used by clients. It has <tt class="docutils literal"><span class="pre">begin()</span></tt>, <tt class="docutils literal"><span class="pre">end()</span></tt>, <tt class="docutils literal"><span class="pre">step()</span></tt> and <tt class="docutils literal"><span class="pre">next_step_delay()</span></tt>
methods, which the client (usually a media renderer) uses to control the transition.
<tt class="docutils literal"><span class="pre">next_step_delay()</span></tt> needs an explanation: it returns the delay until the engine
would like to get the next call to <tt class="docutils literal"><span class="pre">step()</span></tt> from the renderer.</p>
<p>On top of this central object there is a multiple inheritance graph where one leg
is machine dependent, and does the actual bitblit operation to combine two images.
The other leg is machine independent, but dependent on the actual transition type,
and computes the parameters for the bitblit. These two then come together in a stub
class that has all the functionality for a specific transition type on a specific
platform.</p>
<p>There is a <a class="reference" href="../models/transition.pdf">UML diagram for transitions</a> showing how these classes relates to each other.</p>
</div>
</div>
</body>
</html>
