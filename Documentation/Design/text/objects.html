<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>Ambulant design, objects</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="ambulant-design-objects">
<h1 class="title">Ambulant design, objects</h1>
<div class="section" id="jack-jansen-16-jun-03">
<h1><a name="jack-jansen-16-jun-03">Jack Jansen, 16-Jun-03.</a></h1>
<p>Objects we need:</p>
<ul class="simple">
<li>Event processor. This is the mainloop plus the event/callback mechanism.</li>
<li>Data Source. Think of these as &quot;media items&quot;, they may refer to a URL
or part of a multiplexed stream or so, and provide data to renderers and
to the parser.</li>
<li>Decoders. It may be a good idea to have a decoder class that has the
same interface as a data source and is stacked on a real data source.</li>
<li>Region. This is an area of screen space (or a speaker). It is &quot;what
the user sees&quot;.</li>
<li>Data sink. This is where renderers send their data.</li>
<li>Renderers. These decode data streams, handle timing and do bitblitting
or push audio through.</li>
<li>Clocks. These advance a virtual time.</li>
<li>Document Scheduler. This reads a document and runs it.</li>
<li>Timeline. This executes a single timeline.</li>
</ul>
<p>Objects we may need:</p>
<ul class="simple">
<li>Resource. Control access to scarce resources (bandwidth, number of
open files).</li>
</ul>
</div>
<div class="section" id="event-processor">
<h1><a name="event-processor">Event processor</a></h1>
<p>The event processor is the heart of the system, and it needs to be thought
out pretty well as the efficiency of it will in a large part determine the
snappyness of the system. Design of this is TBD, because it depends on a number
of unknowns (such as how to represent callbacks). We may want to tack on
to existing OS infrastructure (such as the Windows event loop), but that may
be too inefficient.</p>
<p><em>QUESTION</em>: is the event processor a global object? It has to be available when
an object wants to schedule a callback, so it either has to be a global object
or it has to be passed explicitly to constructor methods or when setting the
callback to call. And, if the event processor is a global object, we have the
problem that the HL scheduler also wants to use the data source, but it lives
in a different thread. Is this a problem?</p>
</div>
<div class="section" id="data-source">
<h1><a name="data-source">Data source</a></h1>
<p>A data source is the thing that gives you data. It consists of two classes: a
passive data source which is a placeholder for parameters (URL, clip-begin/clip-end and such)
and which can hold caching information. The second class is the active data
source which actually fetches data and pushes it to the consumer.</p>
<p>The passive data source has a call &quot;preroll()&quot; which creates the active counterpart
behind the scenes, so that a later call to activate() will return quickly.</p>
<p>Data sources are push-based: the client asks
for data, this call returns immedeately, and when the data is available
an event is fired. There is probably also a call that says &quot;don't
send me the event until you have all the data that is there&quot;.</p>
<p><em>QUESTION</em> in addition we could have a call read_all() which does away
with all the event processing (or at least hides it) and just dums all data into a
buffer. Do we need this?</p>
<p><em>QUESTION</em> what sort of push-based API do we want? We could have one where the
producer callback simply signals data availability, and the consumer would then read()
this data (thereby signalling to the producer that it could go get more data).
Alternatively, the producer callback could contain a reference to the data/length.
In that case, if there is more data than the consumer can handle presently, who is
responsible for keeping it? I.e. can the consumer push it back to the producer, or
will it have to do buffering?</p>
<p>Some data sources will be able to handle some of the extra parameters
(clip-begin/end, ignore-repeat) itself, the rest will be passed to 
the renderer to handle.</p>
<p><em>QUESTION</em> is this actually feasible? Is
there a way we could do this? Maybe there is: you pass all
such extra paremeter (lets call them &quot;filtering parameters&quot;) to the
passive data source creation method. The active data source will handle
some of these itself, and those that it can't handle it keeps for future
reference. Then when you start actually reading from the active data source
you first ask for any unhandled filtering parameters and are given this list.
you are then responsible for implementing them.</p>
<p><em>QUESTION</em> there
We need to think about how to handle multiplexed data streams such as RTSP.
It could be that this is simply someone elses problem (the RTSP library),
but maybe we need multiplexed data streams too.</p>
<p>A decoder object gets data from a data source, does something to it (such
as decoding JPEG data) and passes it on.</p>
<blockquote>
I keep flipping back-and-forth about where to do decoding: at the
source end (as stated in the previous paragraph), in the Renderer
object or at the sink. Comments?</blockquote>
<p><em>QUESTION</em> buffer management isn't touched on. Do we need a buffer type?
Or does simply malloced memory, along with strict rules for who is
responsible for freeing it at what time, suffice?</p>
<p><em>QUESTION</em> we could have a subclass timed_active_datasource, for data sources
which refer to timed media. Do we need this, i.e. do we ever want to seek a
datastream? And, if we do want to seek, do we want a subclass or
simply have this funcitonality on all active datasources (to be ignored
on non-timed media)?</p>
</div>
<div class="section" id="data-sink">
<h1><a name="data-sink">Data sink</a></h1>
<p>A data sink is where data is sent. It is invoked with a SMIL region as
parameter, but multiple sinks can share a region, in which case
double-buffering for transitions and such happens there. It has no API
for graphics or such, this is handled by the renderers using the local
graphics APIs. A data sink can send a callback to the renderer for
&quot;redraw&quot; and &quot;reinit&quot;. The latter is redraw on steriods: the underlying
OS window may have changed (end of transition, resize). Probably user
interaction (clicking the mouse) also needs to follow this paradigm.</p>
</div>
<div class="section" id="renderers">
<h1><a name="renderers">Renderers</a></h1>
<p>RendererFactory is called with a data source, data sink and a few other
parameters (such as &quot;ignore implicit repeat in media item&quot;). It returns
a renderer object. The factory can either return a dormant renderer,
which is only a placeholder, or a real renderer. To return a real
renderer, or when a dormant renderer is later activated, we ask all
known renderer classes whether they are able to handle this data source,
and instantiate the first one that matches.</p>
<p>The renderer object interface should allow for at least three different
implementations:</p>
<ol class="arabic simple">
<li>The normal one, where the renderer depends on the data source for
data, decodes it, and sends it to the data sink.</li>
<li>A &quot;third party&quot; renderer, that just grabs the information from the
data source and sink and passes it to a third party engine (think
QuickTime or Direct X).</li>
<li>A mix of the above.</li>
</ol>
<p>We need the dormant renderer object, which only holds the information
needed to allow later activation (on demand?). Otherwise resources may
become scarce: think of a seq with 1000 slides: we don't want to open
all images beforehand or we will run out of file descriptors. But
sometimes the document scheduler must open the data source, if the media
item is part of a switch, for instance.</p>
</div>
<div class="section" id="clocks">
<h1><a name="clocks">Clocks</a></h1>
<p>Clocks come in two flavors. The normal flavor is a free-running clock, a
renderer that is subscribed to it can access it in two modes (depending
on what programming model it prefers): callback or polling. In callback
mode it will get callbacks when the virtual clock time has drifted more
than delta from the wallclock. In polling mode it can ask for the time
and ask for a callback at a specific time/interval. Renderers can also
tell the clock what time they think it is, but this is completely
ignored.</p>
<p>The other clock flavor is the master clock. Each normal clock can have
at most one master clock attached to it. The master clock has the same
API as a normal clock, from the renderer point of view, but it does not
give callbacks and it <em>does</em> listen when the renderer tells it what time
it is (and updates its dependent slave clock). The scheduler assigns a
master clock for the SMIL syncMaster attribute.</p>
</div>
<div class="section" id="smil-document-tree">
<h1><a name="smil-document-tree">SMIL Document tree</a></h1>
<p>The SMIL Document Scheduler opens the document (through a data source)
and parses it into a tree. It then waits for the &quot;play document&quot; event.
Upon receipt it will create the timeline schedule for the root plus anything
that is on the same timeline. It creates the data sources and renderers,
pushes the whole timeline down and fires the event that sets the thing running.
The timeline schedule also contains preloads for the various media items.
Then it waits for more events (probably from the LL scheduler) and does
what is needed for them.</p>
</div>
<div class="section" id="timelines">
<h1><a name="timelines">Timelines</a></h1>
<p>The timelines can also be pushed down early, in which case they
will start preloading. This can be used to do &quot;jump optimization&quot; on
user interaction: if the scheduler can guess where the user is going to
go it can push the schedule down early thereby giving better responsiveness.</p>
<p>The main data structure in a timeline is the the list of (prerequisites, action)
tuples. This is almost a petri-net: when all of the prerequisites have happend
then all action are triggered. There is a difference with a real petri-net in
that some of these tuples are &quot;or&quot; in stead of &quot;and&quot;: as soon as any of the
prerequisites has fired the actions fire. We need a name for these tuples (and
node and event are already taken), &quot;place&quot; seems to be the petri-net standard
but I don't like it...</p>
<p>Actions can either trigger another prerequisite, cause an event to be
sent to a renderer (play, stop, etc), trigger a clock callback later or
do an upcall to the document scheduler. These should probably all be
done through the event processor, so we can use it's priority scheme to
do things in the right order.</p>
<p>The timeline has a number of auxiliary objects:</p>
<ul class="simple">
<li>the renderers used (with their data sources attached),</li>
<li>the clock (or master and slave clock),</li>
<li>probably more.</li>
</ul>
</div>
</div>
</body>
</html>
