<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>Ambulant design, main objects</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="ambulant-design-main-objects">
<h1 class="title">Ambulant design, main objects</h1>
<div class="section" id="sep-03">
<h1><a name="sep-03">30-Sep-03</a></h1>
<p>Objects we need:</p>
<ul class="simple">
<li>Event processor. This is the mainloop plus the event/callback mechanism.</li>
<li>Data Source. Think of these as &quot;media items&quot;, they may refer to a URL
or part of a multiplexed stream or so, and provide data to renderers and
to the parser.</li>
<li>Decoders. It may be a good idea to have a decoder class that has the
same interface as a data source and is stacked on a real data source.</li>
<li>Passive Region. This is an area of screen space (or a speaker). It is &quot;what
the user sees&quot;.</li>
<li>Active region. This is where renderers send their data.</li>
<li>Renderers. These decode data streams, handle timing and do bitblitting
or push audio through.</li>
<li>Clocks. These advance a virtual time.</li>
<li>Document. The representation of a SMIL document.</li>
<li>Document Parser. The parser for a document.</li>
<li>Document Scheduler. This reads a document and runs it.</li>
<li>Timeline. This executes a single timeline.</li>
<li>Player. This is the toplevel object.</li>
</ul>
<p>Objects we may need:</p>
<ul class="simple">
<li>Resource. Control access to scarce resources (bandwidth, number of
open files).</li>
</ul>
<p>In addition we have various auxiliary objects that are explained in
<tt class="literal"><span class="pre">auxobjects.txt</span></tt>.</p>
</div>
<div class="section" id="common-protocols">
<h1><a name="common-protocols">Common protocols</a></h1>
<p>There are a number of (formal and informal) protocols that are shared among
multiple object classes: the <cite>refcounting protocol</cite> and the <cite>active/passive
protocol</cite>.</p>
<p>The <cite>refcounting protocol</cite> is contained in the file <tt class="literal"><span class="pre">lib/refcount.h</span></tt>. It needs to
be implemented only by objects that are truly shared, i.e. any object whose
lifetime is not predetermined by some other object. New instances of refcounted
objects are created using the operator new. Any object that needs to share
a particular instance calls add_ref against this instance. The creator
of the refcounted object and any sharer are responsible to call the release
function of the object when they don't need the object any more.</p>
<p>The <cite>active/passive protocol</cite> is more a pattern than a protocol. The pattern
is used often in Ambulant for objects that go through two stages during
their lifetime: a building stage and an active (running) stage. The passive
object is the object that corresponds to the building stage and the built
stage that follows it. The passive object <em>appears</em> to be immutable.
Once the object actually needs to do work we activate it, giving a new instance
of an active object that does the actual work. The passive object remains
in existence, and can be re-used.</p>
<p>Note that I say &quot;appears immutable&quot;: passive objects could internally cache
information, or keep one or more active instances ready for quick disposal.</p>
</div>
<div class="section" id="clocks">
<h1><a name="clocks">Clocks</a></h1>
<p><em>NOTE</em>: in the current implementation clocks do not yet exist, and
there is only the global realtime clock. The interface is in <tt class="literal"><span class="pre">lib/timer.h</span></tt> and
<tt class="literal"><span class="pre">lib/delta_timer.h</span></tt>.</p>
<p>Clocks come in two flavors. The normal flavor is a free-running clock, a
renderer that is subscribed to it can access it in two modes (depending
on what programming model it prefers): callback or polling. In callback
mode it will get callbacks when the virtual clock time has drifted more
than delta from the wallclock. In polling mode it can ask for the time
and ask for a callback at a specific time/interval. Renderers can also
tell the clock what time they think it is, but this is completely
ignored.</p>
<p>The other clock flavor is the master clock. Each normal clock can have
at most one master clock attached to it. The master clock has the same
API as a normal clock, from the renderer point of view, but it does not
give callbacks and it <em>does</em> listen when the renderer tells it what time
it is (and updates its dependent slave clock). The scheduler assigns a
master clock for the SMIL syncMaster attribute.</p>
<blockquote>
<em>NOTE</em> I am rethinking this section. The fact that some times a clock
is slaved to another clock and sometimes it is slaved to a renderer needs
to be exploited, probably through an interface for any object that can
be master to a clock. Then all clocks will be slaved to such a clock
master, either another clock, a renderer or the &quot;realtime master clock&quot;
object.</blockquote>
</div>
<div class="section" id="smil-document-parser">
<h1><a name="smil-document-parser">SMIL Document parser</a></h1>
<p>To be supplied by KK. Interface is in (I guess) <tt class="literal"><span class="pre">lib/expat_parser.h</span></tt>,
<tt class="literal"><span class="pre">lib/nscontext.h</span></tt> (correct?), <tt class="literal"><span class="pre">lib/parse_attrs.h</span></tt>, <tt class="literal"><span class="pre">lib/region_eval.h</span></tt>,
<tt class="literal"><span class="pre">lib/sax_handler.h</span></tt>, <tt class="literal"><span class="pre">lib/sax_types.h</span></tt> (correct?), <tt class="literal"><span class="pre">lib/smil_handler.h</span></tt>.</p>
</div>
<div class="section" id="timelines">
<h1><a name="timelines">Timelines</a></h1>
<p>Timeline objects again come in active and passive flavors. The passive
flavor is what is created by the SMIL document scheduler, which is then
activated when pushed down, at which point the active timeline starts
running.</p>
<p>Timeline design is elaborated upon in the document <tt class="literal"><span class="pre">timelines.txt</span></tt>,
and the API is in <tt class="literal"><span class="pre">lib/timelines.h</span></tt>.</p>
<p>The timelines can also be pushed down early, in which case they
will start preloading. This can be used to do &quot;jump optimization&quot; on
user interaction: if the scheduler can guess where the user is going to
go it can push the schedule down early thereby giving better responsiveness.</p>
<p>The main data structure in a timeline is the the list of (prerequisites, action)
tuples. This is almost a petri-net: when all of the prerequisites have happend
then all action are triggered. There is a difference with a real petri-net in
that some of these tuples are &quot;or&quot; in stead of &quot;and&quot;: as soon as any of the
prerequisites has fired the actions fire. We need a name for these tuples (and
node and event are already taken), &quot;place&quot; seems to be the petri-net standard
but I don't like it...</p>
<p>Actions can either trigger another prerequisite, cause an event to be
sent to a renderer (play, stop, etc), trigger a clock callback later or
do an upcall to the document scheduler. These should probably all be
done through the event processor, so we can use it's priority scheme to
do things in the right order.</p>
<p>The timeline has a number of auxiliary objects:</p>
<ul class="simple">
<li>the renderers used (with their data sources attached),</li>
<li>the clock (or master and slave clock),</li>
<li>probably more.</li>
</ul>
</div>
</div>
</body>
</html>
