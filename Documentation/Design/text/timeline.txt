Timelines
=========
Jack Jansen, 01-Sep-03
----------------------

This document gives an overview of what is in a timeline object. It is
loosely based on what the old CMIF scheduler looked like. There are some
simplifications, because I think that some of the extra states and transitions
that the CMIF scheduler had are no longer needed because a timeline is only
supposed to schedule self-contained pieces. Sjoerd: could you comment on this?

Conceptual design
-----------------

The sample SMIL document that I use to clarify this is the following::

	<seq id="outerseq">
		<par id="innerpar">
			<ref id="parchild1"/>
			<ref id="parchild2"/>
		</par>
		<ref id="seqchild2"/>
	</seq>
	
The *states* that a node goes through are ``IDLE``, ``PREROLLING``, ``PLAYING``,
``PLAYED`` and ``DONE``. We may want an extra state ``PREROLLED``, but I don't think
we need it. The interesting thing seems to be that the states an active timeline
object itself goes
through are the same. ``PLAYED`` and ``DONE`` need a bit of explanation. A node
goes from ``PLAYING`` to ``PLAYED`` when its implicit or explicit duration is over,
but its freeze duration not. I.e. the thing is logically finished, but you
can still see it. It goes from ``PLAYED`` to ``DONE`` (or directly from ``PLAYING`` to
``DONE``) when its parent decides to stop it playing.

These states give rise to *state-transitions*, and those are what we are
actually interested in. These are the things
that are often called "events" in other such designs, but I think we are
already overusing that term as-is. 

Here is what the timeline for the section above looks like conceptually. 
The semantics used here are that we wait for the state transitions on the
lefthandside of the colon to happen, and as soon as they have happened
we fire the state transitions on the righthandside. If there is more than one
transition on the LHS we use either the ``&&`` operator to wait for all
of them or ``||`` to wait for the first one::

	START_PREROLL_TIMELINE:
		START_PREROLL(outerseq)
	START_PLAY_TIMELINE:
		START_PLAY(outerseq)
	DONE_PLAY_TIMELINE:
		
	START_PREROLL(outerseq):
		START_PREROLL(innerpar)
	START_PLAY(outerseq):
		START_PLAY(innerpar)
	DONE_PLAY(outerseq):
		DONE_PLAY_TIMELINE
				
	START_PREROLL(innerpar):
		START_PREROLL(parchild1),
		START_PREROLL(parchild2)
	START_PLAY(innerpar): 
		START_PLAY(parchild1), 
		START_PLAY(parchild2),
		START_PREROLL(seqchild2)
	DONE_PLAY(parchild1) && DONE_PLAY(parchild2):
		DONE_PLAY(innerpar)
	DONE_PLAY(innerpar):
		STOP_PLAY(parchild1),
		STOP_PLAY(parchild2),
		START_PLAY(seqchild2)
		
	START_PREROLL(parchild1):
		START_PREROLL_RENDERER(parchild1)
	START_PLAY(parchild1):
		START_PLAY_RENDERER(parchild1)
	STOP_PLAY(parchild1):
		STOP_PLAY_RENDERER(parchild1),
		
	START_PREROLL(parchild2):
		START_PREROLL_RENDERER(parchild2)
	START_PLAY(parchild2):
		START_PLAY_RENDERER(parchild2)
	STOP_PLAY(parchild2):
		STOP_PLAY_RENDERER(parchild2),
	
	START_PREROLL(seqchild2):
		START_PREROLL_RENDERER(seqchild2)
	START_PLAY(seqchild2):
		START_PLAY_RENDERER(seqchild2)
	DONE_PLAY(seqchild2):
		STOP_PLAY_RENDERER(seqchild2),
		DONE_PLAY(outerseq)
		
The ``xxx_TIMELINE`` state-transitions are the communication between this timeline
and the highlevel scheduler: the ``START_PREROLL_TIMELINE`` and ``START_PLAY_TIMELINE``
are injected form above to get the ball rolling, the ``DONE_PLAY_TIMELINE`` is
sent back up to notify that the timeline has finished.

The ``START_PREROLL_RENDERER(xx)``, ``START_PLAY_RENDERER(xx)`` and ``STOP_PLAY_RENDERER(xx)`` are 
"side-effect-only"
transitions: the timeline doesn't use these on the lefthandside, their only effect
is to kick renderers and other objects into motion. The ``DONE_PLAY_RENDERER(xx)`` is the
reverse: for media nodes these are generated by the renderer.

There is one more bit of functionality: timed events. For each delay needed a delayer
object is instantiated (with the delay time as parameter). This object appears on a 
righthandside rule as ``DELAY(delayobj)``, at which point the timer starts. When the timer
finishes the event ``DELAY(delayobj)`` fires on the lefthandside.

Design issues still to be handled
---------------------------------

A bit that is still incomplete is region control. The ``passive_region`` is implied
by the node, and ``START_PREROLL_RENDERER``  creates the corresponding ``active_region``
that does the rendering. Implications of (SMIL-) transitions and fill behaviour
are still TBD.

Anchors aren't mentioned explicitly, but I think they can be handled analogous
to normal media nodes. In other words: we treat an anchor simply as another kind
of media node, and the only special thing we do is that we don't send it to a
normal renderer but to an "anchor renderer". This makes media nodes behave
similarly as parallel interior nodes, but I don't think the design here has any problems
with that.

Clocks aren't mentioned yet. It could be that they are implicit (i.e. the renderer
picks up the clock to use from the node), but I think they probably need to be
explicit. This would mean that the ``DELAY`` and all the ``xxx_RENDERER`` state transitions 
get a clock parameter.

Implementation notes
--------------------

Timelines could be optimized pretty aggressively: for any state transition in the RHS
of a rule that occurs alone in the LHS of another rule we can simply replace
it's occurrence in the RHS with its own expansion. This does not happen yet in the current implementation.

Note that the timeline objects come in passive and active flavors, like many other
objects. The passive flavor is created by the document scheduler, which could then hang
if off the SMIL node object. It will then activate it and start it running when needed.
Since activation is in the critical performance path it needs to be fast.
The passive object goes through two stages during its lifetime: a *creation* stage followed by a
*built* stage.

During creation the datastructures more-or-less follow the layout
shown in the example above: a list of ``timeline_node`` objects that stores
all ``timeline_node_event`` objects for a single node; ``timeline_node_event`` objects
storing the information on a single event as a list of ``timeline_lhs_event`` and
``timeline_rhs_event`` objects, which in turn store one ``EVENTCLASS(object)`` reference.

After the upper layer has built the complete timeline it calls the ``timeline.build()``
method to transform these datastructures into a form that is easily executed.
This form consists of a linear array of ``active_action`` objects representing all actions
in all righthandsides, but with symbolic ``timeline_rhs_event`` information replaced by
a numeric index. This index points into the ``active_dependency`` objects, which correspond
one-to-one to a single ``timeline_node_event`` but store only a first and last pointer into
the ``active_action`` array (the actions corresponding to this event) and a counter
(decremented every time this ``active_dependency`` fires, with the actions executed when
the counter hits zero).

Side-effect-only actions are handled similarly, but in stead of having an index into the
``active_dependency`` list and decrementing a counter they run the corresponding external
action when triggered.

The only mutable data structure is the ``active_dependency`` list, the counters of which
are decremented, and this list contains no pointers to other objects hence it can
be copied with a straight ``bcopy()``-like operation. Consequently, on creation of an 
``active_timeline`` object we only need
to create a copy of the ``active_dependency`` list, the ``active_action`` list is kept in
the ``passive_timeline`` object and shared among all active copies.
