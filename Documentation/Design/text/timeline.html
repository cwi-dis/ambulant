<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>Timelines</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="timelines">
<h1 class="title">Timelines</h1>
<div class="section" id="jack-jansen-01-sep-03">
<h1><a name="jack-jansen-01-sep-03">Jack Jansen, 01-Sep-03</a></h1>
<p>This document gives an overview of what is in a timeline object. It is
loosely based on what the old CMIF scheduler looked like. There are some
simplifications, because I think that some of the extra states and transitions
that the CMIF scheduler had are no longer needed because a timeline is only
supposed to schedule self-contained pieces. Sjoerd: could you comment on this?</p>
</div>
<div class="section" id="conceptual-design">
<h1><a name="conceptual-design">Conceptual design</a></h1>
<p>The sample SMIL document that I use to clarify this is the following:</p>
<pre class="literal-block">
&lt;seq id=&quot;outerseq&quot;&gt;
        &lt;par id=&quot;innerpar&quot;&gt;
                &lt;ref id=&quot;parchild1&quot;/&gt;
                &lt;ref id=&quot;parchild2&quot;/&gt;
        &lt;/par&gt;
        &lt;ref id=&quot;seqchild2&quot;/&gt;
&lt;/seq&gt;
</pre>
<p>The <em>states</em> that a node goes through are <tt class="literal"><span class="pre">IDLE</span></tt>, <tt class="literal"><span class="pre">PREROLLING</span></tt>, <tt class="literal"><span class="pre">PLAYING</span></tt>,
<tt class="literal"><span class="pre">PLAYED</span></tt> and <tt class="literal"><span class="pre">DONE</span></tt>. We may want an extra state <tt class="literal"><span class="pre">PREROLLED</span></tt>, but I don't think
we need it. The interesting thing seems to be that the states an active timeline
object itself goes
through are the same. <tt class="literal"><span class="pre">PLAYED</span></tt> and <tt class="literal"><span class="pre">DONE</span></tt> need a bit of explanation. A node
goes from <tt class="literal"><span class="pre">PLAYING</span></tt> to <tt class="literal"><span class="pre">PLAYED</span></tt> when its implicit or explicit duration is over,
but its freeze duration not. I.e. the thing is logically finished, but you
can still see it. It goes from <tt class="literal"><span class="pre">PLAYED</span></tt> to <tt class="literal"><span class="pre">DONE</span></tt> (or directly from <tt class="literal"><span class="pre">PLAYING</span></tt> to
<tt class="literal"><span class="pre">DONE</span></tt>) when its parent decides to stop it playing.</p>
<p>These states give rise to <em>state-transitions</em>, and those are what we are
actually interested in. These are the things
that are often called &quot;events&quot; in other such designs, but I think we are
already overusing that term as-is.</p>
<p>Here is what the timeline for the section above looks like conceptually. 
The semantics used here are that we wait for the state transitions on the
lefthandside of the colon to happen, and as soon as they have happened
we fire the state transitions on the righthandside. If there is more than one
transition on the LHS we use either the <tt class="literal"><span class="pre">&amp;&amp;</span></tt> operator to wait for all
of them or <tt class="literal"><span class="pre">||</span></tt> to wait for the first one:</p>
<pre class="literal-block">
START_PREROLL_TIMELINE:
        START_PREROLL(outerseq)
START_PLAY_TIMELINE:
        START_PLAY(outerseq)
DONE_PLAY_TIMELINE:
        
START_PREROLL(outerseq):
        START_PREROLL(innerpar)
START_PLAY(outerseq):
        START_PLAY(innerpar)
DONE_PLAY(outerseq):
        DONE_PLAY_TIMELINE
                        
START_PREROLL(innerpar):
        START_PREROLL(parchild1),
        START_PREROLL(parchild2)
START_PLAY(innerpar): 
        START_PLAY(parchild1), 
        START_PLAY(parchild2),
        START_PREROLL(seqchild2)
DONE_PLAY(parchild1) &amp;&amp; DONE_PLAY(parchild2):
        DONE_PLAY(innerpar)
DONE_PLAY(innerpar):
        STOP_PLAY(parchild1),
        STOP_PLAY(parchild2),
        START_PLAY(seqchild2)
        
START_PREROLL(parchild1):
        START_PREROLL_RENDERER(parchild1)
START_PLAY(parchild1):
        START_PLAY_RENDERER(parchild1)
STOP_PLAY(parchild1):
        STOP_PLAY_RENDERER(parchild1),
        
START_PREROLL(parchild2):
        START_PREROLL_RENDERER(parchild2)
START_PLAY(parchild2):
        START_PLAY_RENDERER(parchild2)
STOP_PLAY(parchild2):
        STOP_PLAY_RENDERER(parchild2),

START_PREROLL(seqchild2):
        START_PREROLL_RENDERER(seqchild2)
START_PLAY(seqchild2):
        START_PLAY_RENDERER(seqchild2)
DONE_PLAY(seqchild2):
        STOP_PLAY_RENDERER(seqchild2),
        DONE_PLAY(outerseq)
</pre>
<p>The <tt class="literal"><span class="pre">xxx_TIMELINE</span></tt> state-transitions are the communication between this timeline
and the highlevel scheduler: the <tt class="literal"><span class="pre">START_PREROLL_TIMELINE</span></tt> and <tt class="literal"><span class="pre">START_PLAY_TIMELINE</span></tt>
are injected form above to get the ball rolling, the <tt class="literal"><span class="pre">DONE_PLAY_TIMELINE</span></tt> is
sent back up to notify that the timeline has finished.</p>
<p>The <tt class="literal"><span class="pre">START_PREROLL_RENDERER(xx)</span></tt>, <tt class="literal"><span class="pre">START_PLAY_RENDERER(xx)</span></tt> and <tt class="literal"><span class="pre">STOP_PLAY_RENDERER(xx)</span></tt> are 
&quot;side-effect-only&quot;
transitions: the timeline doesn't use these on the lefthandside, their only effect
is to kick renderers and other objects into motion. The <tt class="literal"><span class="pre">DONE_PLAY_RENDERER(xx)</span></tt> is the
reverse: for media nodes these are generated by the renderer.</p>
<p>There is one more bit of functionality: timed events. For each delay needed a delayer
object is instantiated (with the delay time as parameter). This object appears on a 
righthandside rule as <tt class="literal"><span class="pre">DELAY(delayobj)</span></tt>, at which point the timer starts. When the timer
finishes the event <tt class="literal"><span class="pre">DELAY(delayobj)</span></tt> fires on the lefthandside.</p>
</div>
<div class="section" id="design-issues-still-to-be-handled">
<h1><a name="design-issues-still-to-be-handled">Design issues still to be handled</a></h1>
<p>A bit that is still incomplete is region control. The <tt class="literal"><span class="pre">passive_region</span></tt> is implied
by the node, and <tt class="literal"><span class="pre">START_PREROLL_RENDERER</span></tt>  creates the corresponding <tt class="literal"><span class="pre">active_region</span></tt>
that does the rendering. Implications of (SMIL-) transitions and fill behaviour
are still TBD.</p>
<p>Anchors aren't mentioned explicitly, but I think they can be handled analogous
to normal media nodes. In other words: we treat an anchor simply as another kind
of media node, and the only special thing we do is that we don't send it to a
normal renderer but to an &quot;anchor renderer&quot;. This makes media nodes behave
similarly as parallel interior nodes, but I don't think the design here has any problems
with that.</p>
<p>Clocks aren't mentioned yet. It could be that they are implicit (i.e. the renderer
picks up the clock to use from the node), but I think they probably need to be
explicit. This would mean that the <tt class="literal"><span class="pre">DELAY</span></tt> and all the <tt class="literal"><span class="pre">xxx_RENDERER</span></tt> state transitions 
get a clock parameter.</p>
</div>
<div class="section" id="implementation-notes">
<h1><a name="implementation-notes">Implementation notes</a></h1>
<p>Timelines could be optimized pretty aggressively: for any state transition in the RHS
of a rule that occurs alone in the LHS of another rule we can simply replace
it's occurrence in the RHS with its own expansion. This does not happen yet in the current implementation.</p>
<p>Note that the timeline objects come in passive and active flavors, like many other
objects. The passive flavor is created by the document scheduler, which could then hang
if off the SMIL node object. It will then activate it and start it running when needed.
Since activation is in the critical performance path it needs to be fast.
The passive object goes through two stages during its lifetime: a <em>creation</em> stage followed by a
<em>built</em> stage.</p>
<p>During creation the datastructures more-or-less follow the layout
shown in the example above: a list of <tt class="literal"><span class="pre">timeline_node</span></tt> objects that stores
all <tt class="literal"><span class="pre">timeline_node_event</span></tt> objects for a single node; <tt class="literal"><span class="pre">timeline_node_event</span></tt> objects
storing the information on a single event as a list of <tt class="literal"><span class="pre">timeline_lhs_event</span></tt> and
<tt class="literal"><span class="pre">timeline_rhs_event</span></tt> objects, which in turn store one <tt class="literal"><span class="pre">EVENTCLASS(object)</span></tt> reference.</p>
<p>After the upper layer has built the complete timeline it calls the <tt class="literal"><span class="pre">timeline.build()</span></tt>
method to transform these datastructures into a form that is easily executed.
This form consists of a linear array of <tt class="literal"><span class="pre">active_action</span></tt> objects representing all actions
in all righthandsides, but with symbolic <tt class="literal"><span class="pre">timeline_rhs_event</span></tt> information replaced by
a numeric index. This index points into the <tt class="literal"><span class="pre">active_dependency</span></tt> objects, which correspond
one-to-one to a single <tt class="literal"><span class="pre">timeline_node_event</span></tt> but store only a first and last pointer into
the <tt class="literal"><span class="pre">active_action</span></tt> array (the actions corresponding to this event) and a counter
(decremented every time this <tt class="literal"><span class="pre">active_dependency</span></tt> fires, with the actions executed when
the counter hits zero).</p>
<p>Side-effect-only actions are handled similarly, but in stead of having an index into the
<tt class="literal"><span class="pre">active_dependency</span></tt> list and decrementing a counter they run the corresponding external
action when triggered.</p>
<p>The only mutable data structure is the <tt class="literal"><span class="pre">active_dependency</span></tt> list, the counters of which
are decremented, and this list contains no pointers to other objects hence it can
be copied with a straight <tt class="literal"><span class="pre">bcopy()</span></tt>-like operation. Consequently, on creation of an 
<tt class="literal"><span class="pre">active_timeline</span></tt> object we only need
to create a copy of the <tt class="literal"><span class="pre">active_dependency</span></tt> list, the <tt class="literal"><span class="pre">active_action</span></tt> list is kept in
the <tt class="literal"><span class="pre">passive_timeline</span></tt> object and shared among all active copies.</p>
</div>
</div>
</body>
</html>
