Ambulant design, main objects 
=============================

Objects we have:

- `Event processor`_. This is the mainloop plus the event/callback mechanism.
- `Data source`_. Think of these as "media items", they may refer to a URL
  or part of a multiplexed stream or so, and provide data to renderers and
  to the parser.
- `Region`_. This is an area of screen space (or a speaker). It is "what
  the user sees".
- `Renderer`_. These decode data streams, handle timing and do bitblitting
  or push audio through.
- `Clocks`_. These advance a virtual time.
- `Document`_. The representation of a SMIL document.
- `Document parser`_. The parser for a document.
- `Timeline`_. This executes a single timeline.
- `Player`_. This is the toplevel object.

.. _Event processor: event_processor.html
.. _Data source: datasource.html
.. _Region: region.html
.. _Renderer: renderer.html
.. _Document: document.html
.. _Timeline: timeline.html
.. _Player: player.html

For each of these we have an accompanying PDF document with UML graphics
showing how the object relates to other objects. These can be found
in the `models`_ directory.

.. _models: ../models

  
In addition we have various auxiliary objects that are explained in
`auxobjects.txt`_.

.. _auxobjects.txt: auxobjects.html

Common protocols
----------------

There are a number of (formal and informal) protocols that are shared among
multiple object classes: the `refcounting protocol` and the `active/passive
protocol`.

The `refcounting protocol` is contained in the file ``lib/refcount.h``. It needs to
be implemented only by objects that are truly shared, i.e. any object whose
lifetime is not predetermined by some other object. New instances of refcounted
objects are created using the operator new. Any object that needs to share
a particular instance calls add_ref against this instance. The creator
of the refcounted object and any sharer are responsible to call the release
function of the object when they don't need the object any more. 

The `active/passive protocol` is more a pattern than a protocol. The pattern
is used often in Ambulant for objects that go through two stages during
their lifetime: a building stage and an active (running) stage. The passive
object is the object that corresponds to the building stage and the built
stage that follows it. The passive object *appears* to be immutable.
Once the object actually needs to do work we activate it, giving a new instance
of an active object that does the actual work. The passive object remains
in existence, and can be re-used.

Note that I say "appears immutable": passive objects could internally cache
information, or keep one or more active instances ready for quick disposal.

Clocks
------

All clocks adhere to the ``abstract_timer`` interface. This interface
allows you to get the current time and set the speed of the clock.

There is a companion interface ``abstract_timer_client`` (which is actually
a base class of ``abstract_timer``) that allows objects to get notification
of changes in timer speed.

Currently there are two implementations of the ``abstract_timer`` interface:
the operating-system specific realtime clock (of which you cannot set the
speed) and ``timer``, which implements a new zero-based clock
based on another ``abstract_timer``. Its speed is settable
with ``set_speed``, but it is tightly synchronized with its parent clock.

Eventually there will be other implementations of ``timer``,
such as clocks that are allowed to slip synchronization and other such
semantics as required by SMIL.

	Some parts of the design are not finished yet. The intention is that
	various renderers will adhere to the ``abstract_timer`` interface,
	so continuous media can be used as sync master in the SMIL sense.
	It may be a good idea to have all renderers supply the interface,
	with renderers that do not implement their own timing simply deferring
	to their master clock.
	
	Something else that is needed are ``pause()`` and ``unpause()`` calls,
	to signal passing of "non-time". These are not pause and unpause in the
	GUI sense of the word, but they are called by the event_processor or
	other agents when they know real-time is going to pass that may not
	need to be reflected in the clock. Some clocks would ignore these
	calls, some would pause their clock for them. Pause and unpause should
	stack, with the clock only advancing (if the clock doesn't ignore
	pausing) when the pause level is zero.
	
	A nifty idea that needs some thought is the introduction of a
	"GUI clock". This would be a realtime clock, but with one added feature:
	on ``pause()`` it delays redraw requests originating from ambulant,
	releasing them on ``unpause()``. This would have the effect of coalescing
	redraw events scheduled for the same "document time", giving a snappier
	presentation.


Document parser
---------------

To be supplied by KK. Interface is in (I guess) ``lib/expat_parser.h``,
``lib/nscontext.h`` (correct?), ``lib/parse_attrs.h``, ``lib/region_eval.h``,
``lib/sax_handler.h``, ``lib/sax_types.h`` (correct?), ``lib/smil_handler.h``.

