Ambulant design, overall
========================
Jack Jansen, 05-Aug-03
----------------------

This document contains some general thoughts on the Ambulant design. Accompanying
it we have the following documents:

- objects.txt (or objects.html) has a quick description of the main classes.
- timelines.txt (or .html) has a preliminary description of how a timeline
  object works
- datasource.graffle, renderer.graffle and timeline.graffle (or .pdf)
  have a UML view of the relationships between the classes.
  
There are a few more text files and C++ .h header files, but these
are currently not fully up-to-date. Remarks.txt contains, among other things,
a list of solutions we found for various toolkits we need, such as XML
processing.

Design process
--------------

The design is going to consist of a mixed bag of technologies:

- Text files such as this one for informal descriptions.
- C++ header files for class definitions and such.
- Image files for UML pictures.
- Formal text descriptions for each design entity as prescribed by the IEEE STD 1016-1998 
  and explained in sdd-schema.txt.
  
When still applicable design choices that were tried and rejected will
remain listed, with the reason for their rejection. This within the limits or
reasonbility:-).

Open issues and discussion points are indented paragraphs starting with
an emphasized upper case word, as in

	*QUESTION*: explanation of an issue that needs to be resolved.
  
The design is going to be done in C++, but we will try to keep it compatible
with Java or Python, and if possible keep cross-language implementations
possible.  This would not
only benefit people extending it in the long run, but could also jump-start
the initial implementation by re-using the existing GRiNS scheduler.

Boost.python was considered as a way to achieve C++/Python interoperability, but
it turns out it is too heavyweight. SWIG is a possible alternative,
or (for Python) a SWIG/Bgen hybrid.

Terminology
-----------

We need to settle on terminology for use in the design documentation. There
are various terms ("event" and "scheduler" come to mind) that could mean four
or more different things in our context.

We need a term for "stateless from an external point of view". There are
various objects such as data sources that do have lots of internal state
(such as caching information) but appear immutable/stateless from the outside.
For the time being we use the term "passive" for this. The companion "active"
objects are instantiated through the `activate()` call of the passive
objects, at which point they start to do their thing (push data through,
render things, etc).

Source code conventions
-----------------------

Here's a somewhat random list of source code conventions that we have decided
to use (at least: Jack thinks this has been decided, please fix if you disagree):

- Indent 4 spaces, with the following exceptions:

  - namespace doesn't indent at all
  - public:, private: and such indent two spaces
  
- no camelCase, CamelCase or Capitalization in class or variable names
- Underscores to delimit words
- attribute names start with "m\_"
- we have a toplevel namespace ambulant, with a second level of namespaces
  under that
- semi-private classes go into into a namespace named "detail".
- Template type parameters start with an upper case letter
  (as in: ``template <class A> {}``)
- Header files need to include any header files on which they depend, and
  they guard against multiple inclusion with a preprocessor construct.
  
	I think we should use the guards only in the files themselves. There
	are some places now that also check for the guards before doing the
	#include, but this seems like overkill, and moreover makes the code less readable.
	
- Header files are all in an "ambulant" directory, and are included by full
  path, as in::
  
  	#include "ambulant/net/url.h"
  	
- Everything goes into namespace "ambulant", with sub-namespaces "lib",
  "net", etc. Machine-dependent code goes into it's own "unix", "win32", etc
  subnamespace of those.
- Source files have "using namespace ambulant;" at the top, with fully
  qualified declarations. Within bodies you use "using namespace lib::unix"
  whenever needed.
	
- We need to define which preprocessor defines we are going to
  switch on for platform-dependent code, so we don't get `#ifdef _WIN32` in
  one place and something completely different in another place.
  Suggestion:
  
  - `#ifdef _WIN32` to test for Windows
  - something to test for Linux
  - `#ifdef __APPLE__` to test for MacOSX
  - something to test for 386 or other architectures?
  - something to test for Visual Studio versus gcc?

Global structure
----------------

The global structure needs some thought. If we want to be able to use the code
to create, say, a plugin SMIL renderer for use in a browser we need a global
"playback engine" object that has all the others hanging off it (plus factory
methods to create them, etc). There will be a performance penalty to this, but
I don't think it's too big. If we have this global object we might as well
subclass all the children of this object from a common base class that handles
the global administration, and the global object could hold things like
memory allocators, stderr, etc.

	*QUESTION*: is there a way we could handle the memory allocator transparently?
	With things like stdout I think we can (put a member "cout" in our object
	base class, make it always refer to the "cout" in the playback engine), but
	for memory allocators I don't know whether we can break into C++'s new operator.
	This may be important if we want to embed our player, as the embedder may
	hand us a memory allocator to use.

	*COMMENT by KK* I don't see anything special concerning the task of building a plugin 
	SMIL renderer and resource handling. You always have a hierarchy of objects (owners-owned). 
	Each object may own other objects and be responsible for their lifetime 
	(call their constructor and destructor or just assign the job to an auto pointer). 
	You can always make one global root object, the plugin for example; 
	whose destructor will indirectly invoke the destructors of the whole hierarchy.
	Concerning the new operator a) can be overwritten or fully customized if needed 
	b) one may use the placement new operator that re-uses pre-allocated memory.  
	But I think we should do so only if it is really needed (something I cannot see
	from the given reasoning).

With a structure like this the application itself becomes basically a skeleton
embedder: it is responsible for the GUI, handling open/open URL/quit/etc, it creates
playback engine objects when needed and has a small number of callbacks for
"create window" and such.

	*QUESTION*: As we have a number of objects that come in active and passive
	flavors (data sources, data sinks) I am tempted to create a baseclass for
	active and passive containers. On the other hand: it could be seen as
	over-generalization.
	
	*COMMENT by KK*: I think you should create a base class only if you want
	these objects to be managed by an entity in a uniform way and independent
	from their actual type. Otherwise, I think documentation is enough. 
	(Inheritance in most of the cases means a virtual table. 
	There is not any serious cost on this for gross grained objects except 
	that it violates the C++ culture principle of paying for what you use.)    

run-time system
---------------

A point of concern is garbage collection. Because we want to do a C++ implementation
we cannot rely on refcounting or garbage collection in the underlying runtime.
lib/refcount.h has a simple refcounting implementation that we could use for
garbage collection.

	XXXX The refcounting implementation may interfere with any cross-language plans.
	
We need to decide on a per-case basis whether we need refcounting or whether auto_ptr
or plain pointers are more appropriate. Here's some prose by KK that should
be incorporated here:

	I think that ref-counting should be used when it is absolutely needed
	(proven to be needed). It adds an overhead and some complexity since it can
	not happen automatically. On the other hand there are some cases where it
	simplifies the code  a lot. If I judge from my code and the code of others I
	have seen, only very few objects need ref counting. First, objects owned by
	a class, and quite all are, never need to be ref counted. You either use
	auto_ptr or just delete them. The auto_ptr may be used more extensively but
	also most of the times plain pointers can do the job. I think that
	ref-counting is needed when objects containing references are shared by
	completely independent components. For example you have a processor object
	with a queue and other application objects submit work items to this queue
	AND the work items contain references to objects that must be available when
	the work item is executed. If the work items are self-contained or are
	shallow enough to make them self-contained, then you don't need
	ref-counting.

The architecture is going to be fairly tightly coupled. The original idea
of allowing the high-level scheduler to live on a different machine, precomputing
schedules and ending these to a low level scheduler, isn't going to work
for SMIL without putting almost all SMIL complexity in the low-level scheduler.

	XXXX Outcome of the May 21 meeting is that we should be able to do the design
	in such a way that we can allow for a split. For this, we need to de-couple
	the HL-scheduler from the event processor and run it in a separate thread.
	The only communication between HL-scheduler and the rest of the system are
	downcalls to install timelines and upcalls to signal that user interaction has
	happened. What we do need to investigate is whether it is then still possible
	to use the Data Source objects from the scheduler, and/or whether special
	measures are needed for that.

main loop
---------

The basic architecture is going to be event-driven. The alternative
is to use multiple threads all over, but it seems event-driven is the better
choice. An object that wants to use multiple threads can do so more easily
on an event infrastructure than the other way around, but these threads are
"somebody else's problem", as they are hidden from the rest of the architecture.

We do want to allow the option (probably compile time) to allow multiple worker
threads to handle the events. This should be a compile time option, so we don't
incur the overhead of locking the event mgr data structures if there's only a
single worker thread.

Also, although it seems at first glance that some objects, such as a renderer,
would benefit from a threaded architecture it turns out this isn't really so.
The naive threaded implementation::

    while data = read_data():
    	render_data(data)

will not work, because many other things can also happen, such as a user-initiated
event, or the timeline for the renderer being torn down. So, the naive loop
sketched here will become hairy anyway, and look like::

	while event = wait_for_some_interesting_event():
		switch event:
			case DATA: render_data(data)
			case STOP: close_resources_and_exit()
			...

so we might as will split this out in the architecture.

The event handler architecture needs an elaborate priority scheme, that is expressive
enough that the best execution order of things that happen "at the same time"
is automatic.

A problem with the event handler is how to represent an event callback.
lib/callback.h has a solution for this.

If possible we should design the data structures and API such that a shortcut can be
taken (if A schedules a callback for B and nothing of higher priority is runnable then
we call B directly in stead of going through the callback main loop).

integrating third-party tools
-----------------------------

We need to be able to use existing toolkits that take work out of our hands.
Think of QuickTime and DirectX, where you basically pass a URL and say "play" and
have nothing to worry about anymore. Also, existing URL access libraries (such
as the caching infrastructure on windows) and a third party RTSP library need
to be used. This also means we don't have to handle firewalls and what more.
Investigating toolkits we can use needs to be done early, as it may influence
some of the other design issues (GC, event model).

remarks.txt lists options we have for XML parsers, SAX/DOM, regex and RTP/RTSP toolkits.

We need to be able to re-use existing (Explorer, Netscape) plugins, when applicable.

scheduler
---------

The scheduler is going to be split in two. There is a high-level language
dependent scheduler and a low-level independent one. We will write a SMIL
high level scheduler, other people should be able to replace that with, say,
a QuickTime or MPEG-4 scheduler while re-using the low-level scheduler.

The Low-level scheduler is going to be based on fixed timelines. The HL
scheduler identifies a portion of the SMIL document that it can fit on a fixed
timeline (at least: a fully ordered linear timeline), it creates a schedule for this
and pushes it down. These low-level schedules look somewhat like a petri-net,
but they probably need "or" in addition to "and". The LL schedule will contain
events that trigger the HL scheduler when needed (such as when the user clicks
a link, or when the schedule finishes). These timelines are what I referred to
in the past as "multimedia basic blocks". A description of what these timelines
look like is in the file timelines.txt.

The elements in the timeline need enough information to be able to get back at
a HL object from them, so we do the annotation thing. Also, we need to be able
to get from the HL object tree to the timeline objects too, so that hyperjumps
can clear out the relevant timelines. 

Timeline schedules are completely independent, at their level. If one timeline
kills or pauses another one this happens because it sends an event to the
HL scheduler which does the killing or pausing. It may be that timelines can
share a clock (or, probably better, that the clock in a timeline can be slaved
to the clock in another timeline).

I think there are always going to be situations where we want to "restart the world",
i.e. stop everything, tell the highlevel scheduler where we are and let it re-create
the lowlevel schedules to put us back where we were before the restart (but respecting
the new situation that caused the restart). Situations that come to mind are a resize
of the playback window, UI changes like turning on subtitles or other system-test
attributes, etc. We could probably solve each of these cases without restarting,
but if we have the mechanism to do a restart (and do it without too much impact
on the user experience) it can be used as a fallback mechanism, and speed up
initial implementation.

Coupling between high and low level
-----------------------------------

This section is here because I don't know where else to put it. Something that
struck me is that there are a couple of objects that are really one-one mappings
of SMIL nodes at different levels. Specifically, the renderer object is the SMIL
node at the timeline level. Also, it seems that if we decide to always create
a subregion when playing a node there might also be a 1-1 mapping here.

Could we somehow take these three objects and make them "live together" for
efficiency reasons? What I would like is three distinct interfaces but all living
in the same object. At least, optionally: if we at some point decide to do
the decoupled player the objects will become distinct.

But maybe we are good enough off initially by specifying in the UML that this
1-1 relationship exists, and put off any optimization until later.


Missing
-------

Here is a list of bits of the design that I know are missing:

- What events are accepted by what objects, and what the arguments are.
- How we handle anchors. Maybe treat as nodes? 
- How we handle transitions. Maybe also treat as nodes? We probably shouldn't
  follow the SMIL model too closely, as its transitions are a bit funny.
- How we handle subregions. Maybe the same as normal regions, but created dynamically?
  Or are they simply a part of the renderer objects?
  Does this influence anchors too? Do regions belong to a timeline?
- How we handle SMIL animation. This needs to be done in a way that doesn't
  require restarting the world.