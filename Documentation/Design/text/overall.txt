Ambulant design, overall
========================
Jack Jansen, 20-June-03
-----------------------

Here are some general (unstructured) thoughts on the Ambulant design.

Design process
--------------

The design is going to consist of a mixed bag of technologies:

- Text files such as this one for informal descriptions.
- C++ header files for class definitions and such.
- Image files for UML pictures.
- XXXX (Kleanthis: please check this sentence) more formal text documents
  as explained in sdd-schema.txt.
  
The design is going to be done in C++, but we will try to keep it compatible
with Java or Python, and if possible keep cross-language implementations
possible.  This would not
only benefit people extending it in the long run, but could also jump-start
the initial implementation by re-using the existing GRiNS scheduler.

Boost.python was considered as a way to achieve C++/Python interoperability, but
it turns out it is too heavyweight. SWIG is a possible alternative,
or (for Python) a SWIG/Bgen hybrid.

Terminology
-----------

We need to settle on terminology for use in the design documentation. There
are various terms ("event" and "scheduler" come to mind) that could mean four
or more different things in our context.

We need a term for "stateless from an external point of view". There are
various objects such as data sources that do have lots of internal state
(such as caching information) but appear immutable/stateless from the outside.

Source code conventions
-----------------------

Here's a somewhat random list of source code conventions that we have decided
to use (at least: Jack thinks this has been decided, please fix if you disagree):

- Indent 4 spaces, with the following exceptions:

  - namespace doesn't indent at all
  - public:, private: and such indent two spaces
  
- no camelCase, CamelCase or Capitalization in class or variable names
- Underscores to delimit words
- attribute names start with "m\_"
- we have a toplevel namespace ambulant, with a second level of namespaces
  under that
- semi-private classes go into into a namespace named "detail".
- Template type parameters start with an upper case letter
  (as in: ``template <class A> {}``)

run-time system
---------------

A point of concern is garbage collection. Because we want to do a C++ implementation
we cannot rely on refcounting or garbage collection in the underlying runtime.
lib/refcount.h has a simple refcounting implementation that we could use for
garbage collection.

	XXXX The refcounting implementation may interfere with any cross-language plans.
	
We need to decide on a per-case basis whether we need refcounting or whether auto_ptr
or plain pointers are more appropriate. Here's some prose by KK that should
be incorporated here:

	I think that ref-counting should be used when it is absolutely needed
	(proven to be needed). It adds an overhead and some complexity since it can
	not happen automatically. On the other hand there are some cases where it
	simplifies the code  a lot. If I judge from my code and the code of others I
	have seen, only very few objects need ref counting. First, objects owned by
	a class, and quite all are, never need to be ref counted. You either use
	auto_ptr or just delete them. The auto_ptr may be used more extensively but
	also most of the times plain pointers can do the job. I think that
	ref-counting is needed when objects containing references are shared by
	completely independent components. For example you have a processor object
	with a queue and other application objects submit work items to this queue
	AND the work items contain references to objects that must be available when
	the work item is executed. If the work items are self-contained or are
	shallow enough to make them self-contained, then you don't need
	ref-counting.

The architecture is going to be fairly tightly coupled. The original idea
of allowing the high-level scheduler to live on a different machine, precomputing
schedules and ending these to a low level scheduler, isn't going to work
for SMIL without putting almost all SMIL complexity in the low-level scheduler.

	XXXX Outcome of the May 21 meeting is that we should be able to do the design
	in such a way that we can allow for a split. For this, we need to de-couple
	the HL-scheduler from the event processor and run it in a separate thread.
	The only communication between HL-scheduler and the rest of the system are
	downcalls to install timelines and upcalls to signal that user interaction has
	happened. What we do need to investigate is whether it is then still possible
	to use the Data Source objects from the scheduler, and/or whether special
	measures are needed for that.

main loop
---------

The basic architecture is going to be event-driven. The alternative
is to use multiple threads all over, but it seems event-driven is the better
choice. An object that wants to use multiple threads can do so more easily
on an event infrastructure than the other way around, but these threads are
"somebody else's problem", as they are hidden from the rest of the architecture.

We do want to allow the option (probably compile time) to allow multiple worker
threads to handle the events. This should be a compile time option, so we don't
incur the overhead of locking the event mgr data structures if there's only a
single worker thread.

Also, although it seems at first glance that some objects, such as a renderer,
would benefit from a threaded architecture it turns out this isn't really so.
The naive threaded implementation::

    while data = read_data():
    	render_data(data)

will not work, because many other things can also happen, such as a user-initiated
event, or the timeline for the renderer being torn down. So, the naive loop
sketched here will become hairy anyway, and look like::

	while event = wait_for_some_interesting_event():
		switch event:
			case DATA: render_data(data)
			case STOP: close_resources_and_exit()
			...

so we might as will split this out in the architecture.

The event handler architecture needs an elaborate priority scheme, that is expressive
enough that the best execution order of things that happen "at the same time"
is automatic.

A problem with the event handler is how to represent an event callback.
lib/callback.h has a solution for this.

If possible we should design the data structures and API such that a shortcut can be
taken (if A schedules a callback for B and nothing of higher priority is runnable then
we call B directly in stead of going through the callback main loop).

integrating third-party tools
-----------------------------

We need to be able to use existing toolkits that take work out of our hands.
Think of QuickTime and DirectX, where you basically pass a URL and say "play" and
have nothing to worry about anymore. Also, existing URL access libraries (such
as the caching infrastructure on windows) and a third party RTSP library need
to be used. This also means we don't have to handle firewalls and what more.
Investigating toolkits we can use needs to be done early, as it may influence
some of the other design issues (GC, event model).

remarks.txt lists options we have for XML parsers, SAX/DOM, regex and RTP/RTSP toolkits.

We need to be able to re-use existing (Explorer, Netscape) plugins, when applicable.

scheduler
---------

The scheduler is going to be split in two. There is a high-level language
dependent scheduler and a low-level independent one. We will write a SMIL
high level scheduler, other people should be able to replace that with, say,
a QuickTime or MPEG-4 scheduler while re-using the low-level scheduler.

The Low-level scheduler is going to be based on fixed timelines. The HL
scheduler identifies a portion of the SMIL document that it can fit on a fixed
timeline (at least: a fully ordered linear timeline), it creates a schedule for this
and pushes it down. These low-level schedules look somewhat like a petri-net,
but they probably need "or" in addition to "and". The LL schedule will contain
events that trigger the HL scheduler when needed (such as when the user clicks
a link, or when the schedule finishes). These timelines are what I referred to
in the past as "multimedia basic blocks". A description of what these timelines
look like is in the file timelines.txt.

The elements in the timeline need enough information to be able to get back at
a HL object from them, so we do the annotation thing. Also, we need to be able
to get from the HL object tree to the timeline objects too, so that hyperjumps
can clear out the relevant timelines. 

Timeline schedules are completely independent, at their level. If one timeline
kills or pauses another one this happens because it sends an event to the
HL scheduler which does the killing or pausing. It may be that timelines can
share a clock (or, probably better, that the clock in a timeline can be slaved
to the clock in another timeline).

I think there are always going to be situations where we want to "restart the world",
i.e. stop everything, tell the highlevel scheduler where we are and let it re-create
the lowlevel schedules to put us back where we were before the restart (but respecting
the new situation that caused the restart). Situations that come to mind are a resize
of the playback window, UI changes like turing on subtitles or other system-test
attributes, etc. We could probably solve each of these cases without restarting,
but if we have the mechanism to do a restart (and do it without too much impact
on the user experience) it can be used as a fallback mechanism, and speed up
initial implementation.

Missing
-------

Here is a list of bits of the design that I know are missing:

- What events are accepted by what objects, and what the arguments are.
- How we handle anchors. Maybe treat as nodes? 
- How we handle transitions. Maybe also treat as nodes? We probably shouldn't
  follow the SMIL model too closely, as its transitions are a bit funny.
- How we handle subregions. Maybe the same as normal regions, but created dynamically?
  Or are they simply a part of the renderer objects?
  Does this influence anchors too? Do regions belong to a timeline?
- How we handle SMIL animation. This needs to be done in a way that doesn't
  require restarting the world.