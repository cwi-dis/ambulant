Notes on design of keep-renderers
=================================

I assume that we are implementing only part of the official SMIL spec for prefetch:
we ignore the bandwidth and size parameters, and we ignore the scheduler aspects (begin,
end, dur). We simply start prefetching data until our datasource buffers are filled
to capacity.

I assume the following interface for the renderer and playable (the important bits).
This is slightly different from what is currently implemented.
All methods are from playable, unless otherwise indicated.

Note to self: many renderers have an "m_activated" member, but the meaning is unclear.
In some places it is used to mean "the internal engine is running", in other places
it means "the engine is running, and I'm connected to a surface". This needs fixing.

playable and renderer API
-------------------------

create(event_processor *evp, playable_notification *context)	
	/// Constructor function.
	
destructor()
	/// Can be called in any state, i.e. simulates stop() and post_stop()
	/// as required.
	
init_with_node(node *n)
	/// Bind the renderer to a node, either prefetch or media.
	/// Records node, cookie, URL, clip_begin/end, etc.
	
renderer::set_surface(surface *dest)
	/// Bind renderer output to a surface.
	
preroll(double when, double where, double how_much)
	/// If the datasource is not open yet it is opened and positioned.
	/// If the datasource is already opened it is re-positioned, unless the new
	/// start position is equal to the old "official" current position.
	/// start reading data.
	/// Record where as old "official" position.
	/// when and how_much are ignored.
	/// Note: doing two prerolls with the same "where" parameter after each other
	/// should have exactly the effect that the second one does nothing.
	
start(double t, playable_notification::cookie_type cookie)
	/// preroll(0, t, 0)
	/// assert(surface)
	/// Start rendering media.
	/// Synchronize media clock.
	
stop()
	/// Scheduler-aspect of stop: emits stopped(), removes node/cookie binding.
	/// Returns a boolean, if it returns true the renderer is actually continuing
	/// and it may be cached. For complete playback stop a later call to
	/// post_stop() is required.

post_stop()
	/// Playback stops. May only be called if stop() returned false.
	/// Note that a renderer is still restartable after post_stop().
	
I'm ignoring pause(), resume(), seek() and wantclicks() here, as they have no influence
on the grand scheme of things. I am assuming that these calls can only be issued
between start() and stop(). NEW: We want to put assert()s in to check this.

playable_notification interface
-------------------------------

The notification interface is unchanged:

started(cookie)
	/// Emitted when the node starts playback
	
stopped(cookie)
	/// Emitted when the node stops playback
	
All the other ones can only occur between those two. Every
start() will generate exactly one started(). Exactly one stopped() is always emitted,
after started(). stopped() may be emitted before or after stop(). NEW: we want to
put in asserts to check this.

internal events
---------------

There are a number of internal events (internal to the renderer) that also
cause state changes:

END_OF_FILE
	/// The data source signals end-of-file
	
END_OF_CLIP
	/// The data source position goes past clipEnd.

API call sequences
------------------

For a normal node, that is not followed by a second node referring to the same URL,
the order of calls will be:
	
	create()
	init_with_node(node)
	set_surface(node_surface)
	preroll(node_parameters)
	start()
	stop()
	post_stop()
	
For two nodes back-to-back, the order will be:

	create()
	init_with_node(node1)
	set_surface(node1_surface)
	preroll(node1_parameters)
	start()
	stop()
	init_with_node(node2)
	set_surface(node2_surface)
	preroll(node2_parameters)
	start()
	stop()
	post_stop()
	
There is now the question of how to handle mismatching surfaces. Probably not difficult, but we need
to be aware of it.

For a prefetch, later followed by a normal node, the order will be (this assumes prefetch is completely
transparent to the scheduler, doesn't react to dur/begin/end, doesn't do other timing calculations, very
similar to how state commands are implemented):

	create()
	init_with_node(prefetch_node)
	preroll(prefetch_node_parameters)
	init_with_node(normal_node)
	set_surface(normal_node_surface)
	preroll(normal_node_parameters)
	start()
	stop()
	post_stop()
	
Alternative for prefetch (assuming prefetch is very much like a normal video/audio/ref/etc):
	create()
	init_with_node(prefetch_node)
	preroll(prefetch_node_parameters)
	start()
	stop()
	init_with_node(normal_node)
	set_surface(normal_node_surface)
	preroll(normal_node_parameters)
	start()
	stop()
	post_stop()
	
For the time being, we have decided to try the first solution: prefetch has a side-effect which
triggers at the beginning of its duration and continues "forever" afterwards. The scheduler ignores
it for its calculations.

Changes, and rationale
----------------------

I've split the constructor into two, effectively putting all the functionality that was duplicated
in update_context_info() into the (very similar) new init_with_node().

I've moved initialization of context::cookie to start(): if start is never called the
renderer should never ever do callbacks.

I've removed start_prefetch(), because we already had an (unused, and forgotten) API
called preroll().

Bo's call stop_but_keeping_renderer() is now called simply stop(). The "second half"
of the old stop, which actually stops playback, is now called post_stop(). The return value
of stop() is new too.
